Learning Neo4j 3.x second edition 1독 후 주요 내용 요약

chap 1 그래프 이론과 데이터베이스

    p47
        types of database

            navigational database

            relational database

            nosql database

                key-value store: redis, dynamodb

                column family store: bigtable, cassandra, hbase

                document store: mongodb, couchdb

                graph database: neo4j

    p65
        neo4j basics

            node        1:1..N  label

            relation    1:1     type

chap 2 Neo4j 시작하기

    p81
        cypher language
            https://en.wikipedia.org/wiki/Cypher_(query_language)

    p82
        opencypher
            TODO: https://www.opencypher.org/

    p87
        license
            community edition - GPLv3
            enterprise edition - AGPLv3 or NTCL

    p89
        installation options

            windows (jre bundled)
                server
                    download zip
                    console mode
                        bin\neo4j console
                        http://localhost:7474/browser
                        ctrl-c for stop
                    service mode
                        bin\neo4j install-service
                        neo4j start
                        neo4j stop
                desktop (recommended)
                    neo4j-desktop-version-setup.exe

            mac or linux (no jre bundle)
                bin/neo4j start
                http://localhost:7474

            graph as a service
                graphenedb
                    this provides a free tier
                heroku
                graphstory
                graphgrid
                azure
                clevercloud
                ovh
                google cloud platform
                openshift
                aws

            neo4j sandbox
                7 day free tier

            docker
                ubuntu mint linux
                    install docker-ce

                        required packages
                            sudo apt-get -y install apt-transport-https ca-certificates curl

                        add docker.com key to local keys
                            sudo -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

                        add docker repo to the system
                            sudo add-apt-repository "deb [arch=amd64 https://download.docker.com/linux/ubuntu$(lsb_release -cs) stable"

                    file system prep

                        cd ~
                        mkdir neo4j
                        cd neo4j
                        mkdir logs data

                    run neo4j 3.1.2 in docker container

                        docker run --rm --publish=7474:7474 --publis=7687:7687 --volume=$HOME/neo4j/data:/data --volume=$HOME/neo4j/logs:/logs neo4j:3.1.2
                        docker ps
                        docker stop <container_id>

                    run neo4j 4.0

                        docker run \
                            -p 7474:7474 -p 7687:7687 \
                            -v $PWD/data:/data \
                            -v $PWD/plugins:/plugins \
                            --name neo4j-apoc \
                            -e NEO4J_apoc_export_file_enabled=true \
                            -e NEO4J_apoc_import_file_enabled=true \
                            -e NEO4J_apoc_import_file_use__neo4j__config=true \
                            -e NEO4JLABS_PLUGINS=\[\"apoc\"\] \
                            neo4j:4.0

        versions
            Release Release         EOL             Compatible Driver Versions
            4.2     Nov 17, 2020    May 16, 2022    4.2, 4.1, 4.0
            4.1     Jun 23, 2020    Dec 23, 2021    4.2, 4.1, 4.0
            4.0     Jan 15, 2020    Jul 14, 2021    4.2, 4.1, 4.0
            3.5     Nov 29, 2018    Nov 28, 2021    4.2, 4.1, 4.0, 1.7
            3.4     May 17, 2018    Mar 31, 2020    1.7, 1.6
            3.3     Oct 24, 2017    Apr 28, 2019    1.7, 1.6, 1.5, 1.4
            3.2     May 11, 2017    Nov 31, 2018    1.6, 1.5, 1.4, 1.3
            3.1     Dec 13, 2016    Jun 13, 2018    1.6, 1.5, 1.4, 1.3, 1.2, 1.1
            3.0     Apr 16, 2016    Oct 31, 2017    1.5, 1.4, 1.3, 1.2, 1.1, 1.0
            2.3     Oct 21, 2015    Apr 21, 2017
            2.2     Mar 25, 2015    Sep 25, 2016
            2.1     May 29, 2014    Nov 29, 2015
            2.0     Dec 11, 2013    Jun 11, 2015
            1.9     May 21, 2013    Nov 21, 2014
            1.8     Sep 28, 2012    Mar 28, 2014
            1.7     Apr 18, 2012    Oct 18, 2013
            1.6     Jan 22, 2012    Jul 22, 2013
            1.5     Nov 9, 2011     Mar 9, 2013
            1.4     Jul 8, 2011     Jan 8, 2013
            1.3     Apr 12, 2011    Sep 12, 2012
            1.2     Dec 29, 2010    Jun 29, 2012
            1.1     Jul 30, 2010    Jan 30, 2012
            1.0     Feb 23, 2010    Aug 23, 2011

chap 3 neo4j data modelling

    p124
        data structure
            nodes
            relationships
            properties
            labels

    p126
        er modelling
            user stories:
                extract entities from nouns
                extract properties from adjectives
                extract relationships from vers

        problems with er model
            no direction
            too many joins

    p131
        graph modelling
            start with user stories
            best practices
                use case를 사용하여 관계 정렬하기
                n-ary 관계를 주의 깊게 다루자
                granulate pattern을 주의깊게 다루자
                    "이것을 property로 다루어야 하는가 아니면 node로 만들어야 하는가"와 같은 질문을 해보자.
                    고려사항: node를 평가하는 것이 property를 평가하는 것보다 속도가 빠르다.

    p139
        함정
            하나의 노드에 너무 많은 property를 넣는다 (anti pattern)
            하나의 노드가 여러 개념을 나타낸다 (anti pattern)
            연결되지 않은 그래프
            고밀집 노드 패턴 (anti pattern) -> fan out 노드로 해결한다

chap 4 사이퍼 시작하기

    p148
        #
        CREATE (romeo:Person{name: "Romeo"}) - [:LOVES] -> (juliet:Person{name:"Juliet"})

        #
        MATCN (n)
        RETURN n

    p151 CRUD - CREATE

        # 한 줄로 할 때 id 필요없음.
        CREATE (:Person{name: "Romeo"}) - [:LOVES] -> (:Person{name:"Juliet"})

        # 그런데 아래와 같이 하면 노드가 중복 생성됨
        CREATE (:Person{name: "Romeo"}) - [:LOVES] -> (:Person{name:"Juliet"})
        CREATE (:Person{name:"Juliet"}) - [:LOVES] -> (:Person{name: "Romeo"})

        # identifier를 사용하여 두 줄로하면 중복이 제거된다 (의도적인 typo 있음)
        CREATE (romeo:Person{firstName: "Romeo", age: 13}) - [:LOVES] -> (juliet:Person{name:"Juliet", age: 13})

        CREATE (juliet) - [:LOVES] -> (romeo)
        RETURN romeo, juliet

        # 중복 제거를 위한 더 나은 표현이 있다 -> MERGE

    p154 READ

        MATCH (n:Person)
        WHERE n.name = "Juliet" or n.firstName = "Juliet"
        RETURN n

        MATCH (n:Person) - [:LOVES] - ()
        WHERE toLower(n.name) = "juliet"
        RETURN n ORDER BY n.age
        SKIP 2 LIMIT 5

    p156 UPDATE

        # 특정 노드의 property 변경
        MATCH (n:Person{name: "Juliet"}
        WHERE n.age = 13
        SET n.age = 14
        RETURN n

        # Q: 아래 두 문장은 성능이 똑같은가? => query planner를 돌려보자.

            MATCH (n:Person{name: "Juliet"} WHERE n.age = 13 SET n.age = 14 RETURN n

            MATCH (n:Person} WHERE n.name = "Juliet" and n.age = 13 SET n.age = 14 RETURN n

        # 모든 노드의 property 변경
        MATCH (n:Person)
        SET n.age = n.age + 1
        RETURN n

        # 노드에 레이블 추가
        MATCH (n:Person)
        WHERE n.age >= 12 AND n.age < 18
        SET n:Teen
        RETURN n

        # 노드 레이블 제거
        MATCH (n:Person)
        WHERE n.age >= 18
        REMOVE n:Teen
        RETURN n

        # property가 없는 경우에만 초기화
        MATCH (n:Person)
        WHERE n.age is null
        SET n.age = 0
        RETURN n

        # 여러 property를 동시에 변경 (방법 1)
        MATCH (n:Person)
        SET n.age = 0, n.smell = "teenSpirit"
        RETURN n

        # 여러 property를 동시에 변경 (방법 2)
        MATCH (n:Person)
        SET n.age = 0
        SET n.smell = "teenSpirit"
        RETURN n

    p158 DELETE

        # 노드 삭제 (relationship이 있으면 실패함)
        MATCH (r:Person{lastName: "Montague"})
        DELETE r

        # 연결된 relationship을 포함하여 노드 삭제
        MATCH (r:Person{lastName: "Montague"})
        DETACH DELETE r

    p159 사이퍼 키워드

        MATCH       패턴 매칭

        WHERE       필터링

        RETURN      결과를 최종 반환

        WITH        쿼리 내에서 다음 스텝으로 결과를 전달한다

        ORDER BY .. SKIP .. LIMIT ..

        CREATE      노드 또는 관계 생성

        CREATE UNIQUE   중복없이 노드 또는 관계 생성

        MERGE       패턴 매치가 되면 MATCH operation, 패턴 매치 안 되면 CREATE operation을 수행.

            MERGE (me:Person {name: "My Name"})
            ON MATCH me
            SET me.accessed = timestamp()
            ON CREATE me
            SET me.age = 42

        SET         속성, 레이블 변경

        REMOVE      속성, 레이블 삭제

        DELETE      노드, 관계 삭제

            MATCH (me)
            OPTIONAL MATCH (me) - [r] - ()
            DELETE me, r

    p161
        표기법

            node identifier     camel
                romeo

            label               camel beginning with caps
                LabelExample, Person

            relationship        all caps
                LOVES

            property            camel
                propertyExample, age, lastName

            keyword             all caps
                MATCH, WHERE

        UNIQUE INDEX 설정

            CREATE CONSTRAINT ON (p:Person) ASSERT p.identifier IS UNIQUE

        UNIQUE INDEX 설정 제거

            DROP CONSTRAINT ON (p:Person) ASSERT p.identifier IS UNIQUE

    p164

        TODO: 실습

    p169

        # 친구들 나열
        MATCH (le:Dude {name:"Lebowski"}) <- [:FRIEND_OF] - (some:Dude)
        RETURN some

        # 친구의 친구들 나열
        MATCH (le:Dude {name:"Lebowski"}) <- [:FRIEND_OF] - (someA:Dude) <- [:FRIEND_OF] - (someB:Dude)
        RETURN someB

        # 3차 이내의 모든 친구 나열
        MATCH (le:Dude {name:"Lebowski"}) <- [:FRIEND_OF*3] - (some:Dude)
        RETURN DISTINCT some

    p170
        TODO: https://neo4j.com/docs/cypher-refcard/current/

chap 5 사이퍼의 놀라운 프로시저 - APOC

    p174 apoc 설치

        doc
            https://neo4j.com/labs/apoc/4.1/installation/

        download
            https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/4.1.0.0

            full 또는 core 하나만 다운로드하여 $NEO4J_HOME/plugins 에 넣는다. 둘 다 넣지 않는다.
            https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/download/4.1.0.0/apoc-4.1.0.0-all.jar를 plugins에 복사
            apoc.nlp.*를 사용하려면 apoc-mongodb-dependencies-4.1.0.0.jar 다운로드
            apoc.mongodb.*를 사용하려면 apoc-nlp-dependencies-4.1.0.0.jar 다운로드

        windows, mac, linux (local)

            neo4j stop
            neo4j start

            neo4j restart

        docker

            cd ~/neo4j
            mkdir plugins

            plugins 옵션 추가하여 container 재생성

                docker run \
                    -p 7474:7474 -p 7687:7687 \
                    -v $PWD/data:/data \
                    -v $PWD/logs:/logs \
            +       -v $PWD/plugins:/plugins \
                    --name neo4j-apoc \
                    -e NEO4J_apoc_export_file_enabled=true \
                    -e NEO4J_apoc_import_file_enabled=true \
                    -e NEO4J_apoc_import_file_use__neo4j__config=true \
                    -e NEO4JLABS_PLUGINS=\[\"apoc\"\] \
                    neo4j:4.0

    p176 apoc 상태 체크

        CALL dbms.functions() YIELD name
        WHERE name STARTS WITH 'apoc.'
        RETURN count(name)
        UNION
        CALL dbms.procedures() YIELD name
        WHERE name STARTS WITH 'apoc.'
        RETURN count(name)

        v3.3.0은 98, 201

    p177 function

        CREATE (p:Person{GUID: apoc.create.UUID()})

    p178 help

        CALL apoc.help('meta')

    p179 schema

        # 3.1
        CALL apoc.meta.graph()

        # 3.2+
        CALL db.schema()

    p182 apoc 사용 권한 설정

        # 이것이 없으면 apoc.algo.pagerank를 사용할 수 없다.
        conf/neo4j.conf
    +       dbms.security.procedures.unrestricted=apoc.*

        Random graph generator

            CALL apoc.generate.ba(1000, 2, 'Person', 'FRIEND_OF')

            Q: 왜 p to p 관계를 찾지?

            MATCH (p:Person) - [FRIEND_OF] - (p)
            RETURN p

        랜덤 그래프 생성 알고리즘

            https://neo4j.com/labs/apoc/4.1/graph-updates/graph-generators/
                apoc.generate.ba
                apoc.generate.complete
                apoc.generate.er
                apoc.generate.simple
                apoc.generate.ws

    p183 pagerank 테스트

        # create nodes
        FOREACH (id IN range(0, 1000) | CREATE (n:Node {id: id}))

        # create relationships
        # Q: LIMIT과 WHERE는 순서를 뒤집어야 하는 거 아닌가?
        MATCH (n1:Node), (n2:Node)
        WITH n1, n2
        LIMIT 1000000
        WHERE rand() < 0.1
        CREATE (n1) - [:TYPE_1] -> (n2)

        # call pagerank
        MATCH (node:Node)
        WITH collect(node) as nodes
        CALL apoc.algo.pageRank(nodes) YIELD node, score
        RETURN node, score
        ORDER BY score DESC

    p185 timed run

        # usage
        CALL apoc.cypher.runTimeboxed(stmt, params, timeoutInMs)

        # example
        CALL apoc.cypher.runTimeboxed('MATCH (n) RETURN n', NULL, 2)

    p186 function 'link': 노드 집합에 대해 relationship을 만든다.

        # EARTHBRO_OF 관계 생성

        MATCH (p:Person)
        WITH collect(p) as persons
        CALL apoc.nodes.link(persons, 'EARTHBRO_OF')
        RETURN length(persons)

        # EARTHBRO_OF 관계 카운트

        MATCH (p:Person) - [r:EARTHBRO_OF] - (m:Person)
        RETURN p, count(r)

    p186 다른 주제들

        TODO Trigger

        TODO Refactoring => 뒤에 나옴

        TODO TTL

        TODO Date, Time

        TODO CouchDB, ElasticSearch, MongoDB

chap 6 사이퍼 확장하기

    p190
        git clone https://github.com/neo4j-examples/neo4j-procedure-template

            src\main\java\example\GetRelationshipTypes.java
            src\main\java\example\Join.java
            src\main\java\example\Last.java
            src\main\java\example\TraverseDemo.java
            src\test\java\example\GetRelationshipTypesTests.java
            src\test\java\example\JoinTest.java
            src\test\java\example\LastTest.java
            src\test\java\example\TraverseDemoTest.java
            src\test\resources\movie.cypher

            neo4j.version 4.2.3     class version 55 (java 11)

    p190
        custom 함수 만들기

            # 싱글 value 리턴하는 함수

            learningneo4j.isOdd(num)

    +           package learningneo4j;

                public class OddEven {
    +               @UserFunction
    +               @Description("Returns true if odd")
    +               public Boolean isOdd(@Name("number") Long number) {
                        if (number == null)
                            return false;
                        return number % 2 == 1;
                    }
                }

                mvn clean package

                output 파일을 plugins 로 복사

                test 1
                    #
                    CREATE (t:Test (val: 15))

                    #
                    MATCH (t:Test) WHERE learningneo4j.isOdd(t.val)
                    RETURN t

                test 2
                    Q: unwind와 collect 가 비슷한 시리즈인 듯?  unwind는 []를 rows로. collect은 rows를 []로?
                    Q: WITH random에서 random은 rows 아니었나? 그걸 그냥 val:random 에 사용한다고?
                    #
                    UNWIND apoc.coll.randomItems(range(0, 1000), 15) as random
                    WITH random
                    CREATE (t:Test (val:random))
                    RETURN t


            # 싱글 value 리턴하는 함수

            example.join(['s1', 's2'], ',')

                src\main\java\example\Join.java
                    1: package example;
                    3: import java.util.List;
                    5: import org.neo4j.procedure.Description;
                    6: import org.neo4j.procedure.Name;
                    7: import org.neo4j.procedure.UserFunction;
                    9: /**
                   10:  * This is an example how you can create a simple user-defined function for Neo4j.
                   11:  */
                   12: public class Join {
    +              14:     @UserFunction
    +              15:     @Description("example.join(['s1','s2',...], delimiter) - join the given strings with the given delimiter.")
                   16:     public String join(
                   17:             @Name("strings") List<String> strings,
                   18:             @Name(value = "delimiter", defaultValue = ",") String delimiter) {
                   19:         if (strings == null || delimiter == null) {
                   20:             return null;
                   21:         }
                   22:         return String.join(delimiter, strings);
                   23:     }
                   24: }

    p193
        custom procedure 용도
            rss, json 등 인터넷 소스를 이용하여 그래프에 데이터 추가
            기존 데이터에서 그래프 정리 등.

        unique constraint

            # 제약 생성
            create constraint on (ln:LastName) assert ln.lastName is unique

            # LastName 레이블이 없는 노트 확인. 이것이 0을 리턴해야 한다. Q: 뭐라고? 이게 뭘 한다고?
            match (n:LastName)

        실행하고자 하는 query:

            # 모든 LastName 레이블이 있는 노드를 삭제
            MATCH (ln:LastName)
            DETECH DELETE (ln)

            # LastName 레이블 그루핑을 다시 함.
            MATCH (p:Person)
            WITH learningneo4j.getLastWord(p.name) as lw, p
            MERGE (ln:LastName {lastName: lw}
            WITH ln, p
            CREATE (p) - [:IS_NAMED] -> (ln)

        regroupByLastName procedure 구현

        +   package learningneo4j;

        +   @Procedure
            @Description('CALL learningneo4j.regroupByLastName()')
            public void regroupByLastName() {
                Driver driver = GraphDatabase.driver("bolt://localhost", AuthTokens.basic("neo4j", "password"));
                try (Session session = driver.session()) {
                    try (Transaction tx = session.beginTransaction()) {
                        tx.run("MATCH (ln:LastName) DETECH DELETE (ln)");
                        tx.run("MATCH (p:Person) " +
                               "WITH learningneo4j.getLastWord(p.name) as lw, p " +
                               "MERGE (ln:LastName {lastName: lw} " +
                               "WITH ln, p " +
                               "CREATE (p) - [:IS_NAMED] -> (ln)");
                        tx.success();
                    }
                }
            }

        regroupByLastName의 결과로 생성된 노드를 보는 방법

            MATCH (a) <- [r:IS_NAMED] - (p:Person)
            RETURN a, r, p LIMITE 50

        새 노드를 생성한 후 그것을 리턴하려면 위 procedure를 아래와 같이 수정한다.

            package learningneo4j;

        +   @Procedure(mode = Mode.WRITE)
        +   @Description('CALL learningneo4j.regroupByLastNameVerbose()')
        +   public Stream<StringResult> regroupByLastNameVerbose() {
                Driver driver = GraphDatabase.driver("bolt://localhost", AuthTokens.basic("neo4j", "password"));
                try (Session session = driver.session()) {
                    try (Transaction tx = session.beginTransaction()) {
                        tx.run("MATCH (ln:LastName) DETECH DELETE (ln)");
        +               StatementResult result =
                            tx.run("MATCH (p:Person) " +
                                   "WITH learningneo4j.getLastWord(p.name) as lw, p " +
                                   "MERGE (ln:LastName {lastName: lw} " +
                                   "WITH ln, p " +
                                   "CREATE (p) - [:IS_NAMED] -> (ln)");
                        tx.success();
        +               return result.list(r -> new StringResult(r.get(0).toString())).stream();
                    }
                }
            }

    p197 custom 집계 함수

        # 집계 결과를 리턴하는 함수

            src\main\java\example\Last.java
                1: package example;
                3: import org.neo4j.procedure.*;
                5: /**
                6:  * This is an example how you can create a simple user-defined function for Neo4j.
                7:  */
                8: public class Last {
        +      10:     @UserAggregationFunction("example.last")
               11:     @Description("example.last(value) - returns last non-null row")
               12:     public LastFunction last() {
               13:         return new LastFunction();
               14:     }
               17:     public static class LastFunction {
               19:         private Object lastValue;
        +      21:         @UserAggregationUpdate
               22:         public void aggregate(@Name("value") Object value) {
               23:             if (value != null) {
               24:                 this.lastValue = value;
               25:             }
               26:         }
        +      28:         @UserAggregationResult
               29:         public Object result() {
               30:             return lastValue;
               31:         }
               32:     }
               33: }

        대략 이렇게 사용?

            # 각 LastName에서 마지막 firstName을 리턴.
            MATCH (ln:LastName) -- (p:Person)
            RETURN ln, example.last(p.firstName) as lastFirstName

    p199
        현재 서버에 설치된 custom aggregate function의 목록을 확인하는 방법은 없다 (as of 3.1.2)

        Aggregating functions
            https://neo4j.com/docs/cypher-manual/current/functions/aggregating/

    p199 Unmanaged extensino - JAX-RS 2.0 code

        https://neo4j.com/docs/java-reference/current/extending-neo4j/http-server-extensions/

        Required dependencies for neo4j 3.1.2:

            # 둘 다 provided. neo4j runtime이 두 가지를 다 가지고 있다는 뜻임.
            org.neo4j:neo4j:3.1.2:provided
            javax.ws.rs:javax.ws.rs-api:2.0:provided

        사용법 먼저: 이렇게 사용하고 싶음.

            http://localhost:7474/learningneo4j/persons/lastnames

        각 path element는 아래와 같이 지정함.

            /learningneo4j      <= package learningneo4j
            /persons            <= @Path("/persons") on class
            /lastnames          <= @Path("/lastnames") on method

        코드 PersonResource.java

            package learningneo4j;

            @Path("/persons")
            public class PersonResource {
        +       private final GraphDatabaseService db;
                public PersonResource(@javax.ws.rs.core.Context GraphDatabaseService db) {
                    this.db = db;
                }

                @GET
                @Path("/lastnames")
                @Produces(MediaType.TEXT_PLAIN)
                public String getLastNames() {
        +           try (Transaction tx = db.beginTx()) {   // 트랜잭션은 필수다
        +               ResourceIterator<Node> nodes = db.findNodes(Label.label("LastName"));
        +               List<String> lastNames = new ArrayList<String>();
                        Node n = null;
                        while (nodes.hasNext()) {
                            n = nodes.next();
                            lastNames.add((String) n.getProperty("lastName"));
                        }
                        nodes.close();
                        tx.success();
                        return lastNames.toString();
                    }
                }
            }

        Output jar 파일을 plugins 폴더로 복사.

        테스트.

        unit test 작성 방법은 https://neo4j.com/docs/java-reference/current/extending-neo4j/http-server-extensions/ 참조.

    p203 JSON streaming response

        키는 JsonGenerator를 사용한다는 점.

        Required dependency for neo4j 3.1.2:

            org.codehaus.jackson:jackson-maper-asl:1.9.7:provided

        사용법

            http://localhost:7474/learningneo4j/persons/friends/Damion%20Hand

        FriendsResource.java

        +   package learningneo4j;

        +   @Path("/friends")
            public class FriendsResource {
                private final GraphDatabaseService db;
                private final ObjectMapper objectMapper;
                private static final RelationshipType FRIEND_OF = RelationshipType.withName("FRIEND_OF");
                private static final Label PERSON = Label.label("Person");

                public FriendsResource(@javax.ws.rs.core.Context GraphDatabaseService db) {
                    this.db = db;
                    this.objectMapper = objectMapper;
                }

                @GET
        +       @Path("/{personName}")
                public Response findFriends(@PathParam("personName") final String personName) {
                    StreamingOutput stream = new StreamingOutput() {

                        @Override
                        public void write(OutputStream os) throws IOExceptino, WebApplicationException {
                            JsonGenerator jg = objectMapper.getJsonFactory().createJsonGenerator(os, JsonEncoding.UTF8);
                            jg.writeStartObject();
                            jg.writeFieldName("friends");
                            jg.writeStartArray();

                            try (Transaction tx = db.beginTx(); ResourceIterator<Node> persons = db.findNodes(PERSON, "name", personName)) {
                                while (persons.hasNext()) {
                                    Node person = persons.next();
                                    for (Relationship to : person.getRelationships(FRIEND_OF, OUTGOING)) {
                                        Node friend = to.getEndNode();
                                        jg.writeString(friend.getProperty("name").toString());
                                        for (Relationship from : person.getRelationships(FRIEND_OF, INCOMING)) {
                                            Node friendComing = from.getStartNode();
                                            jg.writeString(friendComing.getProperty("name").toString());
                                        }
                                    }
                                }
                                tx.success();
                            }

                            jg.writeEndArray();
                            jg.writeEndObject();
                            jg.flush();
                            jg.close();
                        }
                    };
                    return Response.ok().entity(stream).type(MediaType.APPLICATION_JSON).build();
                }
            }

        jar 파일을 plugins 폴더로 복사

        http://localhost:7474/learningneo4j/persons/friends/Damion%20Hand 열어본다

            # 아래 query 결과와 같은 내용이 표시된다
            MATCH p = () - [r:FRIEND_OF] -> () RETURN p LIMIT 25

chap 7 Neo4j  쿼리 성능 튜닝

    https://neo4j.com/docs/cypher-manual/current/query-tuning/query-options/

    query
        MATCH (a) RETURN a

    plan
        EXPLAIN MATCH (a) RETURN a

    profiling
        PROFILE MATCH (a) RETURN a

    p211
        PROFILE <query>

        NodeByLabelScan이 AllNodeScan 보다는 낫다.

        web UI를 사용하면 결과를 위에서 아래로 읽는다.

        cypher-shell을 사용하면 결과를 아래에서 위로 읽는다.

    p213

        profile 결과에 나오는 연산자 목록

            모든 노드 스캔
            레이블 스캔
            노드 인덱스 탐색
            노드 인덱스 스캔

        query 파라미터를 지정해야 하면 :param을 사용한다.

            :param title:"Unforgiven"

        query에서 파라미터 title을 참조하는 방법 2가지

            #
            MATCH (n:Movie)
    +       WHERE n.title = $title
            RETURN n

            #
            MATCH (n:Movie)
    +       WHERE n.title = {title}
            RETURN n

        정의된 파라미터를 보려면

            :param

        Q: 아래 /db/data/cypher 사용법 확인

        오 query를 REST 로 모두 실행할 수 있군.

            https://neo4j.com/docs/rest-docs/current/

        Neo4j 브라우저에서 title을 아래와 같이 참조할 수 있다.

            :POST /db/data/cypher
            {
    +           "query": "MATCH(n:Movie{title:{title}}) RETURN n",
    +           "params": {"title": "Unforgiven"}
            }

    p215 인덱스

        # 생성
        CREATE INDEX ON :Tower(name)

        # 목록 보기
        CALL db.indexes

        # 인덱스를 강제로 사용하도록 query 튜닝
        MATCH (t:Tower {name: ""})
    +   USING INDEX t:Tower(name)
        RETURN ...

        # 노드에 여러 레이블이 있을 때 특정 레이블 검색을 강제할 수 있다
        MATCH (t:Location:Towner)
    +   USING SCAN t:Tower
        WHERE t.country = 'JPN'
        RETURN t

    p216 쿼리 작성 시 규칙

        실행 계획을 확인
        행의 수가 급속히 줄어들도록 쿼리 설계
        자원 모니터링 (액세스하는 노드, 속성의 수를 줄이자)
        catesian product은 자제하자
            # 예
            MATCH (n), (m)
            RETURN n, m
        WITH 명령을 이용하여 중간 중간 여러 개의 청크로 잘라주는 것이 좋다.

chap 8 Neo4j 로 데이터 가져오기

    CSV
    JSON
    JDBC
    XML

    p220 LOAD CSV

        https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/

        # csv 파일에 Name, Year 필드를 읽어들임: line을 object으로 해석.
        LOAD CSV WITH HEADERS FROM '<csv-url>' AS line
        CREATE (:Artist {name: line.Name, year: toInt(line.Year)})

        # csv 파일에 헤더가 없으면 아래와 같이 하자: line을 array로 해석. line[offset] where offset is 0 for the first column.
        LOAD CSV FROM '<csv-url>' AS line
        CREATE (:Artist {name: line[1], year: toInt(line[2])})

        # 컬럼명에 공백이 있으면 ``를 사용할 수 있다
        LOAD CSV WITH HEADERS FROM '<csv-url>' AS line
        CREATE (:Artist {name: line.`Name`, year: toInt(line.`Year`)})

        <csv-url>
            # online url begins with https://
            # local file begins with file:///

    p223

        파일을 import 할 때 local file name을 액세스하면 호환성 저하
        따라서 특정한 폴더에서만 import를 수행할 수 있도록 강제하고자 하면

            $NEO_HOME/conf/neo4j.conf

                dbms.directories.import=import

        데이터 파일을 $NEO_HOME/import/level1/artists-with-headers.csv 파일을 준비하고

            LOAD CSV WITH HEADERS FROM 'file:///level1/artists-with-headers.csv' AS line
            CREATE (:Artist {name: line.Name, year: toInt(line.Year)})

        실행하면 level1/artists-with-headers.csv 파일을 import 한다.

        타입 변환
            toInt
            toFloat
            toBoolean

    p223
        import 할 데이터가 많을 경우 주기적 commit 할 수 있다.

        +   USING PERIODIC COMMIT 100
            LOAD CSV WITH HEADERS FROM 'file:///level1/artists-with-headers.csv' AS line
            CREATE (:Artist {name: line.Name, year: toInt(line.Year)})

    p224 JSON 소스에서 데이터 읽기

        기본적으로 온라인에서 읽을 수 있으나, 로컬 파일도 읽으려면 아래 설정이 추가 필요하다

            $NEO_HOME/conf/neo4j.conf

            # 서버 재시작 필요
            apoc.import.file.enabled = true

            #
        +   WITH "file:////tmp/countries.json" AS url
        +   CALL apoc.load.json(url) YIELD value
            RETURN value.cca2, value.cca3, value.name.common, value.name.official, value.capital, value.borders, value.languages

        TODO p225 - p229

    p230 JDBC 소스에서 가져오기

        mysql docker 준비

            docker-mysql.bat

        데이터 준비

            create database learning
            use learning;
            create table os (id long not null, name varchar(50), family varchar(50));
            insert into os values (1, 'debian', 'unix');
            insert into os values (2, 'ubuntu', 'unix');

        제약 생성

            create constraint on (o:Os) assert o.name is unique
            create constraint on (of:OsFamily) assert of.name is unique

        드라이버 로딩

            call apoc.load.driver("com.mysql.jdbc.Driver");

        데이터 로딩

            with "jdbc:mysql://loadhost:3306/learning?user=root" as url
            call apoc.load.jdbc(url, "os") yield row as line
            merge (o:Os {name: line.name})
            merge (of:OsFammily {name: line.family})
            merge (o) - [:FROM] -> (of)

        결과 확인

            match (o:Os) - [:FROM] -> (of:OsFamily)
            return o, of

    p232 XML 소스에서 가져오기

        TODO p233 - p234

chap 9

chap 10

chap 11

chap 12

chap 13

chap 14

chap 15

appendix
