Learning Neo4j 3.x second edition 1독 후 주요 내용 요약

chap 1 그래프 이론과 데이터베이스

    p47
        types of database

            navigational database

            relational database

            nosql database

                key-value store: redis, dynamodb

                column family store: bigtable, cassandra, hbase

                document store: mongodb, couchdb

                graph database: neo4j

    p65
        neo4j basics

            node        1:1..N  label

            relation    1:1     type

chap 2 Neo4j 시작하기

    p81
        cypher language
            https://en.wikipedia.org/wiki/Cypher_(query_language)

    p82
        opencypher
            TODO: https://www.opencypher.org/

    p87
        license
            community edition - GPLv3
            enterprise edition - AGPLv3 or NTCL

    p89
        installation options

            windows (jre bundled)
                server
                    download zip
                    console mode
                        bin\neo4j console
                        http://localhost:7474/browser
                        ctrl-c for stop
                    service mode
                        bin\neo4j install-service
                        neo4j start
                        neo4j stop
                desktop (recommended)
                    neo4j-desktop-version-setup.exe

            mac or linux (no jre bundle)
                bin/neo4j start
                http://localhost:7474

            graph as a service
                graphenedb
                    this provides a free tier
                heroku
                graphstory
                graphgrid
                azure
                clevercloud
                ovh
                google cloud platform
                openshift
                aws

            neo4j sandbox
                7 day free tier

            docker
                ubuntu mint linux
                    install docker-ce

                        required packages
                            sudo apt-get -y install apt-transport-https ca-certificates curl

                        add docker.com key to local keys
                            sudo -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

                        add docker repo to the system
                            sudo add-apt-repository "deb [arch=amd64 https://download.docker.com/linux/ubuntu$(lsb_release -cs) stable"

                    file system prep

                        cd ~
                        mkdir neo4j
                        cd neo4j
                        mkdir logs data

                    run neo4j 3.1.2 in docker container

                        docker run --rm --publish=7474:7474 --publis=7687:7687 --volume=$HOME/neo4j/data:/data --volume=$HOME/neo4j/logs:/logs neo4j:3.1.2
                        docker ps
                        docker stop <container_id>

                    run neo4j 4.0

                        docker run \
                            -p 7474:7474 -p 7687:7687 \
                            -v $PWD/data:/data \
                            -v $PWD/plugins:/plugins \
                            --name neo4j-apoc \
                            -e NEO4J_apoc_export_file_enabled=true \
                            -e NEO4J_apoc_import_file_enabled=true \
                            -e NEO4J_apoc_import_file_use__neo4j__config=true \
                            -e NEO4JLABS_PLUGINS=\[\"apoc\"\] \
                            neo4j:4.0

        versions
            Release Release         EOL             Compatible Driver Versions
            4.2     Nov 17, 2020    May 16, 2022    4.2, 4.1, 4.0
            4.1     Jun 23, 2020    Dec 23, 2021    4.2, 4.1, 4.0
            4.0     Jan 15, 2020    Jul 14, 2021    4.2, 4.1, 4.0
            3.5     Nov 29, 2018    Nov 28, 2021    4.2, 4.1, 4.0, 1.7
            3.4     May 17, 2018    Mar 31, 2020    1.7, 1.6
            3.3     Oct 24, 2017    Apr 28, 2019    1.7, 1.6, 1.5, 1.4
            3.2     May 11, 2017    Nov 31, 2018    1.6, 1.5, 1.4, 1.3
            3.1     Dec 13, 2016    Jun 13, 2018    1.6, 1.5, 1.4, 1.3, 1.2, 1.1
            3.0     Apr 16, 2016    Oct 31, 2017    1.5, 1.4, 1.3, 1.2, 1.1, 1.0
            2.3     Oct 21, 2015    Apr 21, 2017
            2.2     Mar 25, 2015    Sep 25, 2016
            2.1     May 29, 2014    Nov 29, 2015
            2.0     Dec 11, 2013    Jun 11, 2015
            1.9     May 21, 2013    Nov 21, 2014
            1.8     Sep 28, 2012    Mar 28, 2014
            1.7     Apr 18, 2012    Oct 18, 2013
            1.6     Jan 22, 2012    Jul 22, 2013
            1.5     Nov 9, 2011     Mar 9, 2013
            1.4     Jul 8, 2011     Jan 8, 2013
            1.3     Apr 12, 2011    Sep 12, 2012
            1.2     Dec 29, 2010    Jun 29, 2012
            1.1     Jul 30, 2010    Jan 30, 2012
            1.0     Feb 23, 2010    Aug 23, 2011

chap 3 neo4j data modelling

    p124
        data structure
            nodes
            relationships
            properties
            labels

    p126
        er modelling
            user stories:
                extract entities from nouns
                extract properties from adjectives
                extract relationships from vers

        problems with er model
            no direction
            too many joins

    p131
        graph modelling
            start with user stories
            best practices
                use case를 사용하여 관계 정렬하기
                n-ary 관계를 주의 깊게 다루자
                granulate pattern을 주의깊게 다루자
                    "이것을 property로 다루어야 하는가 아니면 node로 만들어야 하는가"와 같은 질문을 해보자.
                    고려사항: node를 평가하는 것이 property를 평가하는 것보다 속도가 빠르다.

    p139
        함정
            하나의 노드에 너무 많은 property를 넣는다 (anti pattern)
            하나의 노드가 여러 개념을 나타낸다 (anti pattern)
            연결되지 않은 그래프
            고밀집 노드 패턴 (anti pattern) -> fan out 노드로 해결한다

chap 4 사이퍼 시작하기

    p148
        #
        CREATE (romeo:Person{name: "Romeo"}) - [:LOVES] -> (juliet:Person{name:"Juliet"})

        #
        MATCN (n)
        RETURN n

    p151 CRUD - CREATE

        # 한 줄로 할 때 id 필요없음.
        CREATE (:Person{name: "Romeo"}) - [:LOVES] -> (:Person{name:"Juliet"})

        # 그런데 아래와 같이 하면 노드가 중복 생성됨
        CREATE (:Person{name: "Romeo"}) - [:LOVES] -> (:Person{name:"Juliet"})
        CREATE (:Person{name:"Juliet"}) - [:LOVES] -> (:Person{name: "Romeo"})

        # identifier를 사용하여 두 줄로하면 중복이 제거된다 (의도적인 typo 있음)
        CREATE (romeo:Person{firstName: "Romeo", age: 13}) - [:LOVES] -> (juliet:Person{name:"Juliet", age: 13})

        CREATE (juliet) - [:LOVES] -> (romeo)
        RETURN romeo, juliet

        # 중복 제거를 위한 더 나은 표현이 있다 -> MERGE

    p154 READ

        MATCH (n:Person)
        WHERE n.name = "Juliet" or n.firstName = "Juliet"
        RETURN n

        MATCH (n:Person) - [:LOVES] - ()
        WHERE toLower(n.name) = "juliet"
        RETURN n ORDER BY n.age
        SKIP 2 LIMIT 5

    p156 UPDATE

        # 특정 노드의 property 변경
        MATCH (n:Person{name: "Juliet"}
        WHERE n.age = 13
        SET n.age = 14
        RETURN n

        # Q: 아래 두 문장은 성능이 똑같은가? => query planner를 돌려보자.

            MATCH (n:Person{name: "Juliet"} WHERE n.age = 13 SET n.age = 14 RETURN n

            MATCH (n:Person} WHERE n.name = "Juliet" and n.age = 13 SET n.age = 14 RETURN n

        # 모든 노드의 property 변경
        MATCH (n:Person)
        SET n.age = n.age + 1
        RETURN n

        # 노드에 레이블 추가
        MATCH (n:Person)
        WHERE n.age >= 12 AND n.age < 18
        SET n:Teen
        RETURN n

        # 노드 레이블 제거
        MATCH (n:Person)
        WHERE n.age >= 18
        REMOVE n:Teen
        RETURN n

        # property가 없는 경우에만 초기화
        MATCH (n:Person)
        WHERE n.age is null
        SET n.age = 0
        RETURN n

        # 여러 property를 동시에 변경 (방법 1)
        MATCH (n:Person)
        SET n.age = 0, n.smell = "teenSpirit"
        RETURN n

        # 여러 property를 동시에 변경 (방법 2)
        MATCH (n:Person)
        SET n.age = 0
        SET n.smell = "teenSpirit"
        RETURN n

    p158 DELETE

        # 노드 삭제 (relationship이 있으면 실패함)
        MATCH (r:Person{lastName: "Montague"})
        DELETE r

        # 연결된 relationship을 포함하여 노드 삭제
        MATCH (r:Person{lastName: "Montague"})
        DETACH DELETE r

    p159 사이퍼 키워드

        MATCH       패턴 매칭

        WHERE       필터링

        RETURN      결과를 최종 반환

        WITH        쿼리 내에서 다음 스텝으로 결과를 전달한다

        ORDER BY .. SKIP .. LIMIT ..

        CREATE      노드 또는 관계 생성

        CREATE UNIQUE   중복없이 노드 또는 관계 생성

        MERGE       패턴 매치가 되면 MATCH operation, 패턴 매치 안 되면 CREATE operation을 수행.

            MERGE (me:Person {name: "My Name"})
            ON MATCH me
            SET me.accessed = timestamp()
            ON CREATE me
            SET me.age = 42

        SET         속성, 레이블 변경

        REMOVE      속성, 레이블 삭제

        DELETE      노드, 관계 삭제

            MATCH (me)
            OPTIONAL MATCH (me) - [r] - ()
            DELETE me, r

    p161
        표기법

            node identifier     camel
                romeo

            label               camel beginning with caps
                LabelExample, Person

            relationship        all caps
                LOVES

            property            camel
                propertyExample, age, lastName

            keyword             all caps
                MATCH, WHERE

        UNIQUE INDEX 설정

            CREATE CONSTRAINT ON (p:Person) ASSERT p.identifier IS UNIQUE

        UNIQUE INDEX 설정 제거

            DROP CONSTRAINT ON (p:Person) ASSERT p.identifier IS UNIQUE

    p164

        TODO: 실습

    p169

        # 친구들 나열
        MATCH (le:Dude {name:"Lebowski"}) <- [:FRIEND_OF] - (some:Dude)
        RETURN some

        # 친구의 친구들 나열
        MATCH (le:Dude {name:"Lebowski"}) <- [:FRIEND_OF] - (someA:Dude) <- [:FRIEND_OF] - (someB:Dude)
        RETURN someB

        # 3차 이내의 모든 친구 나열
        MATCH (le:Dude {name:"Lebowski"}) <- [:FRIEND_OF*3] - (some:Dude)
        RETURN DISTINCT some

    p170
        TODO: https://neo4j.com/docs/cypher-refcard/current/

chap 5 사이퍼의 놀라운 프로시저 - APOC

    p174 apoc 설치

        doc
            https://neo4j.com/labs/apoc/4.1/installation/

        download
            https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/4.1.0.0

            full 또는 core 하나만 다운로드하여 $NEO4J_HOME/plugins 에 넣는다. 둘 다 넣지 않는다.
            https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/download/4.1.0.0/apoc-4.1.0.0-all.jar를 plugins에 복사
            apoc.nlp.*를 사용하려면 apoc-mongodb-dependencies-4.1.0.0.jar 다운로드
            apoc.mongodb.*를 사용하려면 apoc-nlp-dependencies-4.1.0.0.jar 다운로드

        windows, mac, linux (local)

            neo4j stop
            neo4j start

            neo4j restart

        docker

            cd ~/neo4j
            mkdir plugins

            plugins 옵션 추가하여 container 재생성

                docker run \
                    -p 7474:7474 -p 7687:7687 \
                    -v $PWD/data:/data \
                    -v $PWD/logs:/logs \
            +       -v $PWD/plugins:/plugins \
                    --name neo4j-apoc \
                    -e NEO4J_apoc_export_file_enabled=true \
                    -e NEO4J_apoc_import_file_enabled=true \
                    -e NEO4J_apoc_import_file_use__neo4j__config=true \
                    -e NEO4JLABS_PLUGINS=\[\"apoc\"\] \
                    neo4j:4.0

    p176 apoc 상태 체크

        CALL dbms.functions() YIELD name
        WHERE name STARTS WITH 'apoc.'
        RETURN count(name)
        UNION
        CALL dbms.procedures() YIELD name
        WHERE name STARTS WITH 'apoc.'
        RETURN count(name)

        v3.3.0은 98, 201

    p177 function

        CREATE (p:Person{GUID: apoc.create.UUID()})

    p178 help

        CALL apoc.help('meta')

    p179 schema

        # 3.1
        CALL apoc.meta.graph()

        # 3.2+
        CALL db.schema()

    p182 apoc 사용 권한 설정

        # 이것이 없으면 apoc.algo.pagerank를 사용할 수 없다.
        conf/neo4j.conf
    +       dbms.security.procedures.unrestricted=apoc.*

        Random graph generator

            CALL apoc.generate.ba(1000, 2, 'Person', 'FRIEND_OF')

            Q: 왜 p to p 관계를 찾지?

            MATCH (p:Person) - [FRIEND_OF] - (p)
            RETURN p

        랜덤 그래프 생성 알고리즘

            https://neo4j.com/labs/apoc/4.1/graph-updates/graph-generators/
                apoc.generate.ba
                apoc.generate.complete
                apoc.generate.er
                apoc.generate.simple
                apoc.generate.ws

    p183 pagerank 테스트

        # create nodes
        FOREACH (id IN range(0, 1000) | CREATE (n:Node {id: id}))

        # create relationships
        # Q: LIMIT과 WHERE는 순서를 뒤집어야 하는 거 아닌가?
        MATCH (n1:Node), (n2:Node)
        WITH n1, n2
        LIMIT 1000000
        WHERE rand() < 0.1
        CREATE (n1) - [:TYPE_1] -> (n2)

        # call pagerank
        MATCH (node:Node)
        WITH collect(node) as nodes
        CALL apoc.algo.pageRank(nodes) YIELD node, score
        RETURN node, score
        ORDER BY score DESC

    p185 timed run

        # usage
        CALL apoc.cypher.runTimeboxed(stmt, params, timeoutInMs)

        # example
        CALL apoc.cypher.runTimeboxed('MATCH (n) RETURN n', NULL, 2)

    p186 function 'link': 노드 집합에 대해 relationship을 만든다.

        # EARTHBRO_OF 관계 생성

        MATCH (p:Person)
        WITH collect(p) as persons
        CALL apoc.nodes.link(persons, 'EARTHBRO_OF')
        RETURN length(persons)

        # EARTHBRO_OF 관계 카운트

        MATCH (p:Person) - [r:EARTHBRO_OF] - (m:Person)
        RETURN p, count(r)

    p186 다른 주제들

        TODO Trigger

        TODO Refactoring => 뒤에 나옴

        TODO TTL

        TODO Date, Time

        TODO CouchDB, ElasticSearch, MongoDB

chap 6 사이퍼 확장하기

    p190
        git clone https://github.com/neo4j-examples/neo4j-procedure-template

            src\main\java\example\GetRelationshipTypes.java
            src\main\java\example\Join.java
            src\main\java\example\Last.java
            src\main\java\example\TraverseDemo.java
            src\test\java\example\GetRelationshipTypesTests.java
            src\test\java\example\JoinTest.java
            src\test\java\example\LastTest.java
            src\test\java\example\TraverseDemoTest.java
            src\test\resources\movie.cypher

            neo4j.version 4.2.3     class version 55 (java 11)

    p190
        custom 함수 만들기

            # 싱글 value 리턴하는 함수

            learningneo4j.isOdd(num)

    +           package learningneo4j;

                public class OddEven {
    +               @UserFunction
    +               @Description("Returns true if odd")
    +               public Boolean isOdd(@Name("number") Long number) {
                        if (number == null)
                            return false;
                        return number % 2 == 1;
                    }
                }

                mvn clean package

                output 파일을 plugins 로 복사

                test 1
                    #
                    CREATE (t:Test (val: 15))

                    #
                    MATCH (t:Test) WHERE learningneo4j.isOdd(t.val)
                    RETURN t

                test 2
                    Q: unwind와 collect 가 비슷한 시리즈인 듯?  unwind는 []를 rows로. collect은 rows를 []로?
                    Q: WITH random에서 random은 rows 아니었나? 그걸 그냥 val:random 에 사용한다고?
                    #
                    UNWIND apoc.coll.randomItems(range(0, 1000), 15) as random
                    WITH random
                    CREATE (t:Test (val:random))
                    RETURN t


            # 싱글 value 리턴하는 함수

            example.join(['s1', 's2'], ',')

                src\main\java\example\Join.java
                    1: package example;
                    3: import java.util.List;
                    5: import org.neo4j.procedure.Description;
                    6: import org.neo4j.procedure.Name;
                    7: import org.neo4j.procedure.UserFunction;
                    9: /**
                   10:  * This is an example how you can create a simple user-defined function for Neo4j.
                   11:  */
                   12: public class Join {
    +              14:     @UserFunction
    +              15:     @Description("example.join(['s1','s2',...], delimiter) - join the given strings with the given delimiter.")
                   16:     public String join(
                   17:             @Name("strings") List<String> strings,
                   18:             @Name(value = "delimiter", defaultValue = ",") String delimiter) {
                   19:         if (strings == null || delimiter == null) {
                   20:             return null;
                   21:         }
                   22:         return String.join(delimiter, strings);
                   23:     }
                   24: }

    p193
        custom procedure 용도
            rss, json 등 인터넷 소스를 이용하여 그래프에 데이터 추가
            기존 데이터에서 그래프 정리 등.

        unique constraint

            # 제약 생성
            create constraint on (ln:LastName) assert ln.lastName is unique

            # LastName 레이블이 없는 노트 확인. 이것이 0을 리턴해야 한다. Q: 뭐라고? 이게 뭘 한다고?
            match (n:LastName)

        실행하고자 하는 query:

            # 모든 LastName 레이블이 있는 노드를 삭제
            MATCH (ln:LastName)
            DETECH DELETE (ln)

            # LastName 레이블 그루핑을 다시 함.
            MATCH (p:Person)
            WITH learningneo4j.getLastWord(p.name) as lw, p
            MERGE (ln:LastName {lastName: lw}
            WITH ln, p
            CREATE (p) - [:IS_NAMED] -> (ln)

        regroupByLastName procedure 구현

        +   package learningneo4j;

        +   @Procedure
            @Description('CALL learningneo4j.regroupByLastName()')
            public void regroupByLastName() {
                Driver driver = GraphDatabase.driver("bolt://localhost", AuthTokens.basic("neo4j", "password"));
                try (Session session = driver.session()) {
                    try (Transaction tx = session.beginTransaction()) {
                        tx.run("MATCH (ln:LastName) DETECH DELETE (ln)");
                        tx.run("MATCH (p:Person) " +
                               "WITH learningneo4j.getLastWord(p.name) as lw, p " +
                               "MERGE (ln:LastName {lastName: lw} " +
                               "WITH ln, p " +
                               "CREATE (p) - [:IS_NAMED] -> (ln)");
                        tx.success();
                    }
                }
            }

        regroupByLastName의 결과로 생성된 노드를 보는 방법

            MATCH (a) <- [r:IS_NAMED] - (p:Person)
            RETURN a, r, p LIMITE 50

        새 노드를 생성한 후 그것을 리턴하려면 위 procedure를 아래와 같이 수정한다.

            package learningneo4j;

        +   @Procedure(mode = Mode.WRITE)
        +   @Description('CALL learningneo4j.regroupByLastNameVerbose()')
        +   public Stream<StringResult> regroupByLastNameVerbose() {
                Driver driver = GraphDatabase.driver("bolt://localhost", AuthTokens.basic("neo4j", "password"));
                try (Session session = driver.session()) {
                    try (Transaction tx = session.beginTransaction()) {
                        tx.run("MATCH (ln:LastName) DETECH DELETE (ln)");
        +               StatementResult result =
                            tx.run("MATCH (p:Person) " +
                                   "WITH learningneo4j.getLastWord(p.name) as lw, p " +
                                   "MERGE (ln:LastName {lastName: lw} " +
                                   "WITH ln, p " +
                                   "CREATE (p) - [:IS_NAMED] -> (ln)");
                        tx.success();
        +               return result.list(r -> new StringResult(r.get(0).toString())).stream();
                    }
                }
            }

    p197 custom 집계 함수

        # 집계 결과를 리턴하는 함수

            src\main\java\example\Last.java
                1: package example;
                3: import org.neo4j.procedure.*;
                5: /**
                6:  * This is an example how you can create a simple user-defined function for Neo4j.
                7:  */
                8: public class Last {
        +      10:     @UserAggregationFunction("example.last")
               11:     @Description("example.last(value) - returns last non-null row")
               12:     public LastFunction last() {
               13:         return new LastFunction();
               14:     }
               17:     public static class LastFunction {
               19:         private Object lastValue;
        +      21:         @UserAggregationUpdate
               22:         public void aggregate(@Name("value") Object value) {
               23:             if (value != null) {
               24:                 this.lastValue = value;
               25:             }
               26:         }
        +      28:         @UserAggregationResult
               29:         public Object result() {
               30:             return lastValue;
               31:         }
               32:     }
               33: }

        대략 이렇게 사용?

            # 각 LastName에서 마지막 firstName을 리턴.
            MATCH (ln:LastName) -- (p:Person)
            RETURN ln, example.last(p.firstName) as lastFirstName

    p199
        현재 서버에 설치된 custom aggregate function의 목록을 확인하는 방법은 없다 (as of 3.1.2)

        Aggregating functions
            https://neo4j.com/docs/cypher-manual/current/functions/aggregating/

    p199 Unmanaged extensino - JAX-RS 2.0 code

        https://neo4j.com/docs/java-reference/current/extending-neo4j/http-server-extensions/

        Required dependencies for neo4j 3.1.2:

            # 둘 다 provided. neo4j runtime이 두 가지를 다 가지고 있다는 뜻임.
            org.neo4j:neo4j:3.1.2:provided
            javax.ws.rs:javax.ws.rs-api:2.0:provided

        사용법 먼저: 이렇게 사용하고 싶음.

            http://localhost:7474/learningneo4j/persons/lastnames

        각 path element는 아래와 같이 지정함.

            /learningneo4j      <= package learningneo4j
            /persons            <= @Path("/persons") on class
            /lastnames          <= @Path("/lastnames") on method

        코드 PersonResource.java

            package learningneo4j;

            @Path("/persons")
            public class PersonResource {
        +       private final GraphDatabaseService db;
                public PersonResource(@javax.ws.rs.core.Context GraphDatabaseService db) {
                    this.db = db;
                }

                @GET
                @Path("/lastnames")
                @Produces(MediaType.TEXT_PLAIN)
                public String getLastNames() {
        +           try (Transaction tx = db.beginTx()) {   // 트랜잭션은 필수다
        +               ResourceIterator<Node> nodes = db.findNodes(Label.label("LastName"));
        +               List<String> lastNames = new ArrayList<String>();
                        Node n = null;
                        while (nodes.hasNext()) {
                            n = nodes.next();
                            lastNames.add((String) n.getProperty("lastName"));
                        }
                        nodes.close();
                        tx.success();
                        return lastNames.toString();
                    }
                }
            }

        Output jar 파일을 plugins 폴더로 복사.

        테스트.

        unit test 작성 방법은 https://neo4j.com/docs/java-reference/current/extending-neo4j/http-server-extensions/ 참조.

    p203 JSON streaming response

        키는 JsonGenerator를 사용한다는 점.

        Required dependency for neo4j 3.1.2:

            org.codehaus.jackson:jackson-maper-asl:1.9.7:provided

        사용법

            http://localhost:7474/learningneo4j/persons/friends/Damion%20Hand

        FriendsResource.java

        +   package learningneo4j;

        +   @Path("/friends")
            public class FriendsResource {
                private final GraphDatabaseService db;
                private final ObjectMapper objectMapper;
                private static final RelationshipType FRIEND_OF = RelationshipType.withName("FRIEND_OF");
                private static final Label PERSON = Label.label("Person");

                public FriendsResource(@javax.ws.rs.core.Context GraphDatabaseService db) {
                    this.db = db;
                    this.objectMapper = objectMapper;
                }

                @GET
        +       @Path("/{personName}")
                public Response findFriends(@PathParam("personName") final String personName) {
                    StreamingOutput stream = new StreamingOutput() {

                        @Override
                        public void write(OutputStream os) throws IOExceptino, WebApplicationException {
                            JsonGenerator jg = objectMapper.getJsonFactory().createJsonGenerator(os, JsonEncoding.UTF8);
                            jg.writeStartObject();
                            jg.writeFieldName("friends");
                            jg.writeStartArray();

                            try (Transaction tx = db.beginTx(); ResourceIterator<Node> persons = db.findNodes(PERSON, "name", personName)) {
                                while (persons.hasNext()) {
                                    Node person = persons.next();
                                    for (Relationship to : person.getRelationships(FRIEND_OF, OUTGOING)) {
                                        Node friend = to.getEndNode();
                                        jg.writeString(friend.getProperty("name").toString());
                                        for (Relationship from : person.getRelationships(FRIEND_OF, INCOMING)) {
                                            Node friendComing = from.getStartNode();
                                            jg.writeString(friendComing.getProperty("name").toString());
                                        }
                                    }
                                }
                                tx.success();
                            }

                            jg.writeEndArray();
                            jg.writeEndObject();
                            jg.flush();
                            jg.close();
                        }
                    };
                    return Response.ok().entity(stream).type(MediaType.APPLICATION_JSON).build();
                }
            }

        jar 파일을 plugins 폴더로 복사

        http://localhost:7474/learningneo4j/persons/friends/Damion%20Hand 열어본다

            # 아래 query 결과와 같은 내용이 표시된다
            MATCH p = () - [r:FRIEND_OF] -> () RETURN p LIMIT 25

chap 7

chap 8

chap 9

chap 10

chap 11

chap 12

chap 13

chap 14

chap 15

appendix
