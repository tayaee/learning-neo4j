Learning Neo4j 3.x second edition 1독 후 주요 내용 요약

chap 1 그래프 이론과 데이터베이스

    p47
        types of database

            navigational database

            relational database

            nosql database

                key-value store: redis, dynamodb

                column family store: bigtable, cassandra, hbase

                document store: mongodb, couchdb

                graph database: neo4j

    p65
        neo4j basics

            node        1:1..N  label

            relation    1:1     type

chap 2 Neo4j 시작하기

    p81
        cypher language
            https://en.wikipedia.org/wiki/Cypher_(query_language)

    p82
        opencypher
            https://www.opencypher.org/
            https://www.gqlstandards.org/
            https://s3.amazonaws.com/artifacts.opencypher.org/openCypher9.pdf
            https://en.wikipedia.org/wiki/Cypher_(query_language)

            Cypher -> openCypher -> iso standard

    p87
        license
            community edition - GPLv3
            enterprise edition - AGPLv3 or NTCL

    p89
        installation options

            windows (jre bundled)
                server
                    download zip
						https://neo4j.com/download-center/#community
							4.3.2
								https://s3-eu-west-1.amazonaws.com/dist.neo4j.org/neo4j-community-4.3.2-windows.zip?x-amz-security-token=IQoJb3JpZ2luX2VjEDoaCXVzLWVhc3QtMSJGMEQCIH2UOYYISI9Hv84LrKZv9OOZE2A1WQZ75bzi4F5DabAPAiAG3S6srG4y4H4m1pZmqpv3%2F1GsRFMcRnTnVLbAc8byeir6AwgiEAAaDDEyODkxNjY3OTMzMCIM%2FfPoVm5hfwGvYMNuKtcDPoNdOAQnnOxVMAWW3uSFOIOYuPFjWY8COJ3F03XB7adp09uztpZhrA6tPx%2BmPVH6QydmToS1CWdfdYDjlIJr9IToy0quHWcT5D15GMrolCC3Q1NlQJxgJZkomHdu%2FjkBrKAxR75O9XmZEV4JLM4DgruC9Fch1u9j%2FN3sr4Yan9%2BcJ%2BdBl4Vll7YPCKaTSWQFyJTkHorPfVfQOsUG0ME6KWaO9%2BlFBGfyQA161Fh3oSdY%2BLJ0ONNv8zg6iFmAsCHk2biToGkayEc60NtgIOoVyJPk79gC6AzdkHAS9ph%2FeysXt%2FothnoEPBZQehBqsxaeCt21okcexgwjUe%2B1mUWJTR%2FDKNfERf5IOZmAaQoi2lkVUK%2BKxkSYPTEx7kma4dprCakva2WFCga46xpAEAoCXqbUpcqKhoDmfHW1a1TnfzsAyWJwUNMavgq9zsxyrErlHwvZUxnbzTlevHCTnf5CszkajCdqklfJzUwG2U5%2FqjipXsokcqWJnh4KlAM1U%2FU1XOQj%2F0TD7mdekeeYAw7KGaNbmPRdKMbtLpyVnxrYZw2LzKeUOzYlwDlp%2FP0p299XLpCVUmHBaSyP9W%2BHfVPGYmxFezrka5DkqquF4aNDATKzFyV1PL5vMOm8iYcGOqYB8TSrrmlOD0eGFvaUpzpE3C8WUMzHrsRBnEKHEP7gDyOHiHTpbzd7WZhNn2Mgb0cHd87CihY8IZ7v%2FQmFgLVpi7RXkFHhC7rt2GIVfOchfGisSXeesskR%2FrV3Auf98WbZuPf%2Bg0%2FvbOMc%2BT1agZgX0LWaWlN9nh%2BMhVyyjaY8ZP3USm0K1M1k94I5eyxF0whQGa7LViBceYjiCVsjPAh4QTBrznFcTg%3D%3D&AWSAccessKeyId=ASIAR4BAINKRCRVOCN2V&Expires=1625451466&Signature=iateyQ3yWrn4lbcfrt9imPbsJFE%3D
								neo4j-community-4.3.2-windows.zip

                    console mode
                        bin\neo4j console
                        http://localhost:7474/browser
                        ctrl-c for stop
                    service mode
                        bin\neo4j install-service
                        neo4j start
                        neo4j stop
                desktop (recommended)
					https://neo4j.com/download-center/#desktop
						1.4.7
		                    neo4j-desktop-version-setup.exe

            mac or linux (no jre bundle)
                bin/neo4j start
                http://localhost:7474

            graph as a service
                graphenedb
                    this provides a free tier
                heroku
                graphstory
                graphgrid
                azure
                clevercloud
                ovh
                google cloud platform
                openshift
                aws

            neo4j sandbox
                7 day free tier

            docker
                ubuntu mint linux
                    install docker-ce

                        required packages
                            sudo apt-get -y install apt-transport-https ca-certificates curl

                        add docker.com key to local keys
                            sudo -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

                        add docker repo to the system
                            sudo add-apt-repository "deb [arch=amd64 https://download.docker.com/linux/ubuntu$(lsb_release -cs) stable"

                    file system prep

                        cd ~
                        mkdir neo4j
                        cd neo4j
                        mkdir logs data

                    run neo4j 3.1.2 in docker container

                        docker run --rm \
                            --publish=7474:7474 \
                            --publis=7687:7687 \
                            --volume=$HOME/neo4j/data:/data \
                            --volume=$HOME/neo4j/logs:/logs neo4j:3.1.2
                        docker ps
                        docker stop <container_id>

                    run neo4j 4.0

                        docker run \
                            -p 7474:7474 -p 7687:7687 \
                            -v $PWD/data:/data \
                            -v $PWD/plugins:/plugins \
                            --name neo4j-apoc \
                            -e NEO4J_apoc_export_file_enabled=true \
                            -e NEO4J_apoc_import_file_enabled=true \
                            -e NEO4J_apoc_import_file_use__neo4j__config=true \
                            -e NEO4JLABS_PLUGINS=\[\"apoc\"\] \
                            neo4j:4.0

        versions
            Release Release         EOL             Compatible Driver Versions
            4.2     Nov 17, 2020    May 16, 2022    4.2, 4.1, 4.0
            4.1     Jun 23, 2020    Dec 23, 2021    4.2, 4.1, 4.0
            4.0     Jan 15, 2020    Jul 14, 2021    4.2, 4.1, 4.0
            3.5     Nov 29, 2018    Nov 28, 2021    4.2, 4.1, 4.0, 1.7
            3.4     May 17, 2018    Mar 31, 2020    1.7, 1.6
            3.3     Oct 24, 2017    Apr 28, 2019    1.7, 1.6, 1.5, 1.4
            3.2     May 11, 2017    Nov 31, 2018    1.6, 1.5, 1.4, 1.3
            3.1     Dec 13, 2016    Jun 13, 2018    1.6, 1.5, 1.4, 1.3, 1.2, 1.1
            3.0     Apr 16, 2016    Oct 31, 2017    1.5, 1.4, 1.3, 1.2, 1.1, 1.0
            2.3     Oct 21, 2015    Apr 21, 2017
            2.2     Mar 25, 2015    Sep 25, 2016
            2.1     May 29, 2014    Nov 29, 2015
            2.0     Dec 11, 2013    Jun 11, 2015
            1.9     May 21, 2013    Nov 21, 2014
            1.8     Sep 28, 2012    Mar 28, 2014
            1.7     Apr 18, 2012    Oct 18, 2013
            1.6     Jan 22, 2012    Jul 22, 2013
            1.5     Nov 9, 2011     Mar 9, 2013
            1.4     Jul 8, 2011     Jan 8, 2013
            1.3     Apr 12, 2011    Sep 12, 2012
            1.2     Dec 29, 2010    Jun 29, 2012
            1.1     Jul 30, 2010    Jan 30, 2012
            1.0     Feb 23, 2010    Aug 23, 2011

chap 3 neo4j data modelling

    p124
        data structure
            nodes
            relationships
            properties
            labels

    p126
        er modelling
            user stories:
                extract entities from nouns
                extract properties from adjectives
                extract relationships from vers

        problems with er model
            no direction
            too many joins

    p131
        graph modelling
            start with user stories
            best practices
                use case를 사용하여 관계 정렬하기
                n-ary 관계를 주의 깊게 다루자
                granulate pattern을 주의깊게 다루자
                    "이것을 property로 다루어야 하는가 아니면 node로 만들어야 하는가"와 같은 질문을 해보자.
                    고려사항: node를 평가하는 것이 property를 평가하는 것보다 속도가 빠르다.

    p139
        함정
            하나의 노드에 너무 많은 property를 넣는다 (anti pattern)
            하나의 노드가 여러 개념을 나타낸다 (anti pattern)
            연결되지 않은 그래프
            고밀집 노드 패턴 (anti pattern) -> fan out 노드로 해결한다

chap 4 사이퍼 시작하기

    p148
        #
        CREATE (romeo:Person{name: "Romeo"}) - [:LOVES] -> (juliet:Person{name:"Juliet"})

        #
        MATCN (n)
        RETURN n

    p151 CRUD - CREATE

        # 한 줄로 할 때 id 필요없음.
        CREATE (:Person{name: "Romeo"}) - [:LOVES] -> (:Person{name:"Juliet"})

        # 그런데 아래와 같이 하면 노드가 중복 생성됨
        CREATE (:Person{name: "Romeo"}) - [:LOVES] -> (:Person{name:"Juliet"})
        CREATE (:Person{name:"Juliet"}) - [:LOVES] -> (:Person{name: "Romeo"})

        # identifier를 사용하여 두 줄로하면 중복이 제거된다 (의도적인 typo 있음)
        CREATE (romeo:Person{firstName: "Romeo", age: 13}) - [:LOVES] -> (juliet:Person{name:"Juliet", age: 13})

        CREATE (juliet) - [:LOVES] -> (romeo)
        RETURN romeo, juliet

        # 중복 제거를 위한 더 나은 표현이 있다 -> MERGE

    p154 READ

        MATCH (n:Person)
        WHERE n.name = "Juliet" or n.firstName = "Juliet"
        RETURN n

        MATCH (n:Person) - [:LOVES] - ()
        WHERE toLower(n.name) = "juliet"
        RETURN n ORDER BY n.age
        SKIP 2 LIMIT 5

    p156 UPDATE

        # 특정 노드의 property 변경
        MATCH (n:Person{name: "Juliet"}
        WHERE n.age = 13
        SET n.age = 14
        RETURN n

        # Q: 아래 두 문장은 성능이 똑같은가? => query planner를 돌려보자.

            MATCH (n:Person{name: "Juliet"} WHERE n.age = 13 SET n.age = 14 RETURN n

            MATCH (n:Person} WHERE n.name = "Juliet" and n.age = 13 SET n.age = 14 RETURN n

        # 모든 노드의 property 변경
        MATCH (n:Person)
        SET n.age = n.age + 1
        RETURN n

        # 노드에 레이블 추가
        MATCH (n:Person)
        WHERE n.age >= 12 AND n.age < 18
        SET n:Teen
        RETURN n

        # 노드 레이블 제거
        MATCH (n:Person)
        WHERE n.age >= 18
        REMOVE n:Teen
        RETURN n

        # property가 없는 경우에만 초기화
        MATCH (n:Person)
        WHERE n.age is null
        SET n.age = 0
        RETURN n

        # 여러 property를 동시에 변경 (방법 1)
        MATCH (n:Person)
        SET n.age = 0, n.smell = "teenSpirit"
        RETURN n

        # 여러 property를 동시에 변경 (방법 2)
        MATCH (n:Person)
        SET n.age = 0
        SET n.smell = "teenSpirit"
        RETURN n

    p158 DELETE

        # 노드 삭제 (relationship이 있으면 실패함)
        MATCH (r:Person{lastName: "Montague"})
        DELETE r

        # 연결된 relationship을 포함하여 노드 삭제
        MATCH (r:Person{lastName: "Montague"})
        DETACH DELETE r

    p159 사이퍼 키워드

        MATCH       패턴 매칭

        WHERE       필터링

        RETURN      결과를 최종 반환

        WITH        쿼리 내에서 다음 스텝으로 결과를 전달한다

        ORDER BY .. SKIP .. LIMIT ..

        CREATE      노드 또는 관계 생성

        CREATE UNIQUE   중복없이 노드 또는 관계 생성

        MERGE       패턴 매치가 되면 MATCH operation, 패턴 매치 안 되면 CREATE operation을 수행.

            MERGE (me:Person {name: "My Name"})
            ON MATCH me
            SET me.accessed = timestamp()
            ON CREATE me
            SET me.age = 42

        SET         속성, 레이블 변경

        REMOVE      속성, 레이블 삭제

        DELETE      노드, 관계 삭제

            MATCH (me)
            OPTIONAL MATCH (me) - [r] - ()
            DELETE me, r

    p161
        표기법

            node identifier     camel
                romeo

            label               camel beginning with caps
                LabelExample, Person

            relationship        all caps
                LOVES

            property            camel
                propertyExample, age, lastName

            keyword             all caps
                MATCH, WHERE

        UNIQUE INDEX 설정

            CREATE CONSTRAINT ON (p:Person) ASSERT p.identifier IS UNIQUE

        UNIQUE INDEX 설정 제거

            DROP CONSTRAINT ON (p:Person) ASSERT p.identifier IS UNIQUE

    p164

        TODO: 실습

    p169

        # 친구들 나열
        MATCH (le:Dude {name:"Lebowski"}) <- [:FRIEND_OF] - (some:Dude)
        RETURN some

        # 친구의 친구들 나열
        MATCH (le:Dude {name:"Lebowski"}) <- [:FRIEND_OF] - (someA:Dude) <- [:FRIEND_OF] - (someB:Dude)
        RETURN someB

        # 3차 이내의 모든 친구 나열
        MATCH (le:Dude {name:"Lebowski"}) <- [:FRIEND_OF*3] - (some:Dude)
        RETURN DISTINCT some

    p170
        TODO: https://neo4j.com/docs/cypher-refcard/current/

chap 5 사이퍼의 놀라운 프로시저 - APOC

    p174 apoc 설치

        doc
            https://neo4j.com/labs/apoc/4.1/installation/

        download
            https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/4.1.0.0

            full 또는 core 하나만 다운로드하여 $NEO4J_HOME/plugins 에 넣는다. 둘 다 넣지 않는다.
            https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/download/4.1.0.0/apoc-4.1.0.0-all.jar를 plugins에 복사
            apoc.nlp.*를 사용하려면 apoc-mongodb-dependencies-4.1.0.0.jar 다운로드
            apoc.mongodb.*를 사용하려면 apoc-nlp-dependencies-4.1.0.0.jar 다운로드

        windows, mac, linux (local)

            neo4j stop
            neo4j start

            neo4j restart

        docker

            cd ~/neo4j
            mkdir plugins

            plugins 옵션 추가하여 container 재생성

                docker run \
                    -p 7474:7474 -p 7687:7687 \
                    -v $PWD/data:/data \
                    -v $PWD/logs:/logs \
            +       -v $PWD/plugins:/plugins \
                    --name neo4j-apoc \
                    -e NEO4J_apoc_export_file_enabled=true \
                    -e NEO4J_apoc_import_file_enabled=true \
                    -e NEO4J_apoc_import_file_use__neo4j__config=true \
                    -e NEO4JLABS_PLUGINS=\[\"apoc\"\] \
                    neo4j:4.0

    p176 apoc 상태 체크

        CALL dbms.functions() YIELD name
        WHERE name STARTS WITH 'apoc.'
        RETURN count(name)
        UNION
        CALL dbms.procedures() YIELD name
        WHERE name STARTS WITH 'apoc.'
        RETURN count(name)

        v3.3.0은 98, 201

    p177 function

        CREATE (p:Person{GUID: apoc.create.UUID()})

    p178 help

        CALL apoc.help('meta')

    p179 schema

        # 3.1
        CALL apoc.meta.graph()

        # 3.2+
        CALL db.schema()

    p182 apoc 사용 권한 설정

		# 아래 설정을 추가해야 apoc 사용 가능.
        conf/neo4j.conf
    +       dbms.security.procedures.unrestricted=apoc.*

		# 없을 때 나오는 에러
		ERROR: Neo.ClientError.Procedure.ProcedureRegistrationFailed

		# neo4j.conf 수정 후 db restart.

        Random graph generator

            CALL apoc.generate.ba(1000, 2, 'Person', 'FRIEND_OF')

            Q: 왜 p to p 관계를 찾지?

            MATCH (p:Person) - [FRIEND_OF] - (p)
            RETURN p

        랜덤 그래프 생성 알고리즘

            https://neo4j.com/labs/apoc/4.1/graph-updates/graph-generators/
                apoc.generate.ba
                apoc.generate.complete
                apoc.generate.er
                apoc.generate.simple
                apoc.generate.ws

    p183 pagerank 테스트

        # create nodes
        FOREACH (id IN range(0, 1000) | CREATE (n:Node {id: id}))

        # create relationships
        # Q: LIMIT과 WHERE는 순서를 뒤집어야 하는 거 아닌가?
        MATCH (n1:Node), (n2:Node)
        WITH n1, n2
        LIMIT 1000000
        WHERE rand() < 0.1
        CREATE (n1) - [:TYPE_1] -> (n2)

        # call pagerank
        MATCH (node:Node)
        WITH collect(node) as nodes
        CALL apoc.algo.pageRank(nodes) YIELD node, score
        RETURN node, score
        ORDER BY score DESC

    p185 timed run

        # usage
        CALL apoc.cypher.runTimeboxed(stmt, params, timeoutInMs)

        # example
        CALL apoc.cypher.runTimeboxed('MATCH (n) RETURN n', NULL, 2)

    p186 function 'link': 노드 집합에 대해 relationship을 만든다.

        # EARTHBRO_OF 관계 생성

        MATCH (p:Person)
        WITH collect(p) as persons
        CALL apoc.nodes.link(persons, 'EARTHBRO_OF')
        RETURN length(persons)

        # EARTHBRO_OF 관계 카운트

        MATCH (p:Person) - [r:EARTHBRO_OF] - (m:Person)
        RETURN p, count(r)

    p186 다른 주제들

        TODO Trigger

        TODO Refactoring => 뒤에 나옴

        TODO TTL

        TODO Date, Time

        TODO CouchDB, ElasticSearch, MongoDB

chap 6 사이퍼 확장하기

    p190
        git clone https://github.com/neo4j-examples/neo4j-procedure-template

            src\main\java\example\GetRelationshipTypes.java
            src\main\java\example\Join.java
            src\main\java\example\Last.java
            src\main\java\example\TraverseDemo.java
            src\test\java\example\GetRelationshipTypesTests.java
            src\test\java\example\JoinTest.java
            src\test\java\example\LastTest.java
            src\test\java\example\TraverseDemoTest.java
            src\test\resources\movie.cypher

            neo4j.version 4.2.3     class version 55 (java 11)

    p190
        custom 함수 만들기

            # 싱글 value 리턴하는 함수

            learningneo4j.isOdd(num)

    +           package learningneo4j;

                public class OddEven {
    +               @UserFunction
    +               @Description("Returns true if odd")
    +               public Boolean isOdd(@Name("number") Long number) {
                        if (number == null)
                            return false;
                        return number % 2 == 1;
                    }
                }

                mvn clean package

                output 파일을 plugins 로 복사

                test 1
                    #
                    CREATE (t:Test (val: 15))

                    #
                    MATCH (t:Test) WHERE learningneo4j.isOdd(t.val)
                    RETURN t

                test 2
                    Q: unwind와 collect 가 비슷한 시리즈인 듯?  unwind는 []를 rows로. collect은 rows를 []로?
                    Q: WITH random에서 random은 rows 아니었나? 그걸 그냥 val:random 에 사용한다고?
                    #
                    UNWIND apoc.coll.randomItems(range(0, 1000), 15) as random
                    WITH random
                    CREATE (t:Test (val:random))
                    RETURN t


            # 싱글 value 리턴하는 함수

            example.join(['s1', 's2'], ',')

                src\main\java\example\Join.java
                    1: package example;
                    3: import java.util.List;
                    5: import org.neo4j.procedure.Description;
                    6: import org.neo4j.procedure.Name;
                    7: import org.neo4j.procedure.UserFunction;
                    9: /**
                   10:  * This is an example how you can create a simple user-defined function for Neo4j.
                   11:  */
                   12: public class Join {
    +              14:     @UserFunction
    +              15:     @Description("example.join(['s1','s2',...], delimiter) - join the given strings with the given delimiter.")
                   16:     public String join(
                   17:             @Name("strings") List<String> strings,
                   18:             @Name(value = "delimiter", defaultValue = ",") String delimiter) {
                   19:         if (strings == null || delimiter == null) {
                   20:             return null;
                   21:         }
                   22:         return String.join(delimiter, strings);
                   23:     }
                   24: }

    p193
        custom procedure 용도
            rss, json 등 인터넷 소스를 이용하여 그래프에 데이터 추가
            기존 데이터에서 그래프 정리 등.

        unique constraint

            # 제약 생성
            create constraint on (ln:LastName) assert ln.lastName is unique

            # LastName 레이블이 없는 노트 확인. 이것이 0을 리턴해야 한다. Q: 뭐라고? 이게 뭘 한다고?
            match (n:LastName)

        실행하고자 하는 query:

            # 모든 LastName 레이블이 있는 노드를 삭제
            MATCH (ln:LastName)
            DETECH DELETE (ln)

            # LastName 레이블 그루핑을 다시 함.
            MATCH (p:Person)
            WITH learningneo4j.getLastWord(p.name) as lw, p
            MERGE (ln:LastName {lastName: lw}
            WITH ln, p
            CREATE (p) - [:IS_NAMED] -> (ln)

        regroupByLastName procedure 구현

        +   package learningneo4j;

        +   @Procedure
            @Description('CALL learningneo4j.regroupByLastName()')
            public void regroupByLastName() {
                Driver driver = GraphDatabase.driver("bolt://localhost", AuthTokens.basic("neo4j", "password"));
                try (Session session = driver.session()) {
                    try (Transaction tx = session.beginTransaction()) {
                        tx.run("MATCH (ln:LastName) DETECH DELETE (ln)");
                        tx.run("MATCH (p:Person) " +
                               "WITH learningneo4j.getLastWord(p.name) as lw, p " +
                               "MERGE (ln:LastName {lastName: lw} " +
                               "WITH ln, p " +
                               "CREATE (p) - [:IS_NAMED] -> (ln)");
                        tx.success();
                    }
                }
            }

        regroupByLastName의 결과로 생성된 노드를 보는 방법

            MATCH (a) <- [r:IS_NAMED] - (p:Person)
            RETURN a, r, p LIMITE 50

        새 노드를 생성한 후 그것을 리턴하려면 위 procedure를 아래와 같이 수정한다.

            package learningneo4j;

        +   @Procedure(mode = Mode.WRITE)
        +   @Description('CALL learningneo4j.regroupByLastNameVerbose()')
        +   public Stream<StringResult> regroupByLastNameVerbose() {
                Driver driver = GraphDatabase.driver("bolt://localhost", AuthTokens.basic("neo4j", "password"));
                try (Session session = driver.session()) {
                    try (Transaction tx = session.beginTransaction()) {
                        tx.run("MATCH (ln:LastName) DETECH DELETE (ln)");
        +               StatementResult result =
                            tx.run("MATCH (p:Person) " +
                                   "WITH learningneo4j.getLastWord(p.name) as lw, p " +
                                   "MERGE (ln:LastName {lastName: lw} " +
                                   "WITH ln, p " +
                                   "CREATE (p) - [:IS_NAMED] -> (ln)");
                        tx.success();
        +               return result.list(r -> new StringResult(r.get(0).toString())).stream();
                    }
                }
            }

    p197 custom 집계 함수

        # 집계 결과를 리턴하는 함수

            src\main\java\example\Last.java
                1: package example;
                3: import org.neo4j.procedure.*;
                5: /**
                6:  * This is an example how you can create a simple user-defined function for Neo4j.
                7:  */
                8: public class Last {
        +      10:     @UserAggregationFunction("example.last")
               11:     @Description("example.last(value) - returns last non-null row")
               12:     public LastFunction last() {
               13:         return new LastFunction();
               14:     }
               17:     public static class LastFunction {
               19:         private Object lastValue;
        +      21:         @UserAggregationUpdate
               22:         public void aggregate(@Name("value") Object value) {
               23:             if (value != null) {
               24:                 this.lastValue = value;
               25:             }
               26:         }
        +      28:         @UserAggregationResult
               29:         public Object result() {
               30:             return lastValue;
               31:         }
               32:     }
               33: }

        대략 이렇게 사용?

            # 각 LastName에서 마지막 firstName을 리턴.
            MATCH (ln:LastName) -- (p:Person)
            RETURN ln, example.last(p.firstName) as lastFirstName

    p199
        현재 서버에 설치된 custom aggregate function의 목록을 확인하는 방법은 없다 (as of 3.1.2)

        Aggregating functions
            https://neo4j.com/docs/cypher-manual/current/functions/aggregating/

    p199 Unmanaged extensino - JAX-RS 2.0 code

        https://neo4j.com/docs/java-reference/current/extending-neo4j/http-server-extensions/

        Required dependencies for neo4j 3.1.2:

            # 둘 다 provided. neo4j runtime이 두 가지를 다 가지고 있다는 뜻임.
            org.neo4j:neo4j:3.1.2:provided
            javax.ws.rs:javax.ws.rs-api:2.0:provided

        사용법 먼저: 이렇게 사용하고 싶음.

            http://localhost:7474/learningneo4j/persons/lastnames

        각 path element는 아래와 같이 지정함.

            /learningneo4j      <= package learningneo4j
            /persons            <= @Path("/persons") on class
            /lastnames          <= @Path("/lastnames") on method

        코드 PersonResource.java

            package learningneo4j;

            @Path("/persons")
            public class PersonResource {
        +       private final GraphDatabaseService db;
                public PersonResource(@javax.ws.rs.core.Context GraphDatabaseService db) {
                    this.db = db;
                }

                @GET
                @Path("/lastnames")
                @Produces(MediaType.TEXT_PLAIN)
                public String getLastNames() {
        +           try (Transaction tx = db.beginTx()) {   // 트랜잭션은 필수다
        +               ResourceIterator<Node> nodes = db.findNodes(Label.label("LastName"));
        +               List<String> lastNames = new ArrayList<String>();
                        Node n = null;
                        while (nodes.hasNext()) {
                            n = nodes.next();
                            lastNames.add((String) n.getProperty("lastName"));
                        }
                        nodes.close();
                        tx.success();
                        return lastNames.toString();
                    }
                }
            }

        Output jar 파일을 plugins 폴더로 복사.

        테스트.

        unit test 작성 방법은 https://neo4j.com/docs/java-reference/current/extending-neo4j/http-server-extensions/ 참조.

    p203 JSON streaming response

        키는 JsonGenerator를 사용한다는 점.

        Required dependency for neo4j 3.1.2:

            org.codehaus.jackson:jackson-maper-asl:1.9.7:provided

        사용법

            http://localhost:7474/learningneo4j/persons/friends/Damion%20Hand

        FriendsResource.java

        +   package learningneo4j;

        +   @Path("/friends")
            public class FriendsResource {
                private final GraphDatabaseService db;
                private final ObjectMapper objectMapper;
                private static final RelationshipType FRIEND_OF = RelationshipType.withName("FRIEND_OF");
                private static final Label PERSON = Label.label("Person");

                public FriendsResource(@javax.ws.rs.core.Context GraphDatabaseService db) {
                    this.db = db;
                    this.objectMapper = objectMapper;
                }

                @GET
        +       @Path("/{personName}")
                public Response findFriends(@PathParam("personName") final String personName) {
                    StreamingOutput stream = new StreamingOutput() {

                        @Override
                        public void write(OutputStream os) throws IOExceptino, WebApplicationException {
                            JsonGenerator jg = objectMapper.getJsonFactory().createJsonGenerator(os, JsonEncoding.UTF8);
                            jg.writeStartObject();
                            jg.writeFieldName("friends");
                            jg.writeStartArray();

                            try (Transaction tx = db.beginTx();
                                 ResourceIterator<Node> persons = db.findNodes(PERSON, "name", personName)) {
                                while (persons.hasNext()) {
                                    Node person = persons.next();
                                    for (Relationship to : person.getRelationships(FRIEND_OF, OUTGOING)) {
                                        Node friend = to.getEndNode();
                                        jg.writeString(friend.getProperty("name").toString());
                                        for (Relationship from : person.getRelationships(FRIEND_OF, INCOMING)) {
                                            Node friendComing = from.getStartNode();
                                            jg.writeString(friendComing.getProperty("name").toString());
                                        }
                                    }
                                }
                                tx.success();
                            }

                            jg.writeEndArray();
                            jg.writeEndObject();
                            jg.flush();
                            jg.close();
                        }
                    };
                    return Response.ok().entity(stream).type(MediaType.APPLICATION_JSON).build();
                }
            }

        jar 파일을 plugins 폴더로 복사

        http://localhost:7474/learningneo4j/persons/friends/Damion%20Hand 열어본다

            # 아래 query 결과와 같은 내용이 표시된다
            MATCH p = () - [r:FRIEND_OF] -> () RETURN p LIMIT 25

chap 7 Neo4j  쿼리 성능 튜닝

    https://neo4j.com/docs/cypher-manual/current/query-tuning/query-options/

    query
        MATCH (a) RETURN a

    plan
        EXPLAIN MATCH (a) RETURN a

    profiling
        PROFILE MATCH (a) RETURN a

    p211
        PROFILE <query>

        NodeByLabelScan이 AllNodeScan 보다는 낫다.

        web UI를 사용하면 결과를 위에서 아래로 읽는다.

        cypher-shell을 사용하면 결과를 아래에서 위로 읽는다.

    p213

        profile 결과에 나오는 연산자 목록

            모든 노드 스캔
            레이블 스캔
            노드 인덱스 탐색
            노드 인덱스 스캔

        query 파라미터를 지정해야 하면 :param을 사용한다.

            :param title:"Unforgiven"

        query에서 파라미터 title을 참조하는 방법 2가지

            #
            MATCH (n:Movie)
    +       WHERE n.title = $title
            RETURN n

            #
            MATCH (n:Movie)
    +       WHERE n.title = {title}
            RETURN n

        정의된 파라미터를 보려면

            :param

        Q: 아래 /db/data/cypher 사용법 확인

        오 query를 REST 로 모두 실행할 수 있군.

            https://neo4j.com/docs/rest-docs/current/

        Neo4j 브라우저에서 title을 아래와 같이 참조할 수 있다.

            :POST /db/data/cypher
            {
    +           "query": "MATCH(n:Movie{title:{title}}) RETURN n",
    +           "params": {"title": "Unforgiven"}
            }

    p215 인덱스

        # 생성
        CREATE INDEX ON :Tower(name)

        # 목록 보기
        CALL db.indexes

        # 인덱스를 강제로 사용하도록 query 튜닝
        MATCH (t:Tower {name: ""})
    +   USING INDEX t:Tower(name)
        RETURN ...

        # 노드에 여러 레이블이 있을 때 특정 레이블 검색을 강제할 수 있다
        MATCH (t:Location:Towner)
    +   USING SCAN t:Tower
        WHERE t.country = 'JPN'
        RETURN t

    p216 쿼리 작성 시 규칙

        실행 계획을 확인
        행의 수가 급속히 줄어들도록 쿼리 설계
        자원 모니터링 (액세스하는 노드, 속성의 수를 줄이자)
        catesian product은 자제하자
            # 예
            MATCH (n), (m)
            RETURN n, m
        WITH 명령을 이용하여 중간 중간 여러 개의 청크로 잘라주는 것이 좋다.

chap 8 Neo4j 로 데이터 가져오기

    CSV
    JSON
    JDBC
    XML

    p220 LOAD CSV

        https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/

        # csv 파일에 Name, Year 필드를 읽어들임: line을 object으로 해석.
        LOAD CSV WITH HEADERS FROM '<csv-url>' AS line
        CREATE (:Artist {name: line.Name, year: toInt(line.Year)})

        # csv 파일에 헤더가 없으면 아래와 같이 하자: line을 array로 해석.
        # line[offset] where offset is 0 for the first column.
        LOAD CSV FROM '<csv-url>' AS line
        CREATE (:Artist {name: line[1], year: toInt(line[2])})

        # 컬럼명에 공백이 있으면 ``를 사용할 수 있다
        LOAD CSV WITH HEADERS FROM '<csv-url>' AS line
        CREATE (:Artist {name: line.`Name`, year: toInt(line.`Year`)})

        <csv-url>
            # online url begins with https://
            # local file begins with file:///

    p223

        파일을 import 할 때 local file name을 액세스하면 호환성 저하
        따라서 특정한 폴더에서만 import를 수행할 수 있도록 강제하고자 하면

            $NEO_HOME/conf/neo4j.conf

                dbms.directories.import=import

        데이터 파일을 $NEO_HOME/import/level1/artists-with-headers.csv 파일을 준비하고

            LOAD CSV WITH HEADERS FROM 'file:///level1/artists-with-headers.csv' AS line
            CREATE (:Artist {name: line.Name, year: toInt(line.Year)})

        실행하면 level1/artists-with-headers.csv 파일을 import 한다.

        타입 변환
            toInt
            toFloat
            toBoolean

    p223
        import 할 데이터가 많을 경우 주기적 commit 할 수 있다.

        +   USING PERIODIC COMMIT 100
            LOAD CSV WITH HEADERS FROM 'file:///level1/artists-with-headers.csv' AS line
            CREATE (:Artist {name: line.Name, year: toInt(line.Year)})

    p224 JSON 소스에서 데이터 읽기

        기본적으로 온라인에서 읽을 수 있으나, 로컬 파일도 읽으려면 아래 설정이 추가 필요하다

            $NEO_HOME/conf/neo4j.conf

            # 서버 재시작 필요
            apoc.import.file.enabled = true

            #
        +   WITH "file:////tmp/countries.json" AS url
        +   CALL apoc.load.json(url) YIELD value
            RETURN value.cca2, value.cca3, value.name.common, value.name.official,
                value.capital, value.borders, value.languages

        TODO p225 - p229

    p230 JDBC 소스에서 가져오기

        mysql docker 준비

            docker-mysql.bat

        데이터 준비

            create database learning
            use learning;
            create table os (id long not null, name varchar(50), family varchar(50));
            insert into os values (1, 'debian', 'unix');
            insert into os values (2, 'ubuntu', 'unix');

        제약 생성

            create constraint on (o:Os) assert o.name is unique
            create constraint on (of:OsFamily) assert of.name is unique

        드라이버 로딩

            call apoc.load.driver("com.mysql.jdbc.Driver");

        데이터 로딩

            with "jdbc:mysql://loadhost:3306/learning?user=root" as url
            call apoc.load.jdbc(url, "os") yield row as line
            merge (o:Os {name: line.name})
            merge (of:OsFammily {name: line.family})
            merge (o) - [:FROM] -> (of)

        결과 확인

            match (o:Os) - [:FROM] -> (of:OsFamily)
            return o, of

    p232 XML 소스에서 가져오기

        TODO p233 - p234

chap 9 Neo4j Spacial 사용하기

    skipped.

chap 10 Neo4j 보안

    skipped for now.

chap 11 Neo4j 시각화하기

    시각화 라이브러리

        d3.js - neo4j 브라우저에 사용됨
        graphviz
        sigma.js - Linkurio.us에 의해 사용됨
        vivagraph.js
        yworks - 자동 레이아웃 기능 인상적
        cytoscape

        애플리케이션에 라이브러리 통합 패턴 => p280의 다이어그램 참조.

    시각화 솔루션

        gephi
        keylines - 영국
        linkurio.us
        neo4j 브라우저
        www.tomsawyer.com

chap 12 Neo4j를 이용한 데이터 리팩토링

    간단한 변경

    p296 노드 이름 변경

        #
        # Q: 'type'이 뭐지?
        #
        call apoc.refactor.rename.label(oldLabel, newLabel, [nodes])
        call apoc.refactor.rename.type(oldType, newType, [rels])
        call apoc.refactor.rename.nodeProperty(oldName, newName, [nodes])
        call apoc.refactor.rename.typeProperty(oldName, newName, [rels])

    p297 기존에 없던 기본 속성을 노드에 추가하기

        # 속성 추가
        match (n:Tower)
        set n.hasRestaurant = toBoolean("true")
        return n

        # 잘 추가되었는지 확인. 개수가 같아야겠지.
        match (n:Tower)
        where n.hasRestaurant
        return n

    p298 LOAD CSV 와 조합하여 사용할 수도 있다

        using periodic commit 100
        load csv with headers from 'file:///level1/artists-with-headers.csv' as line
        match <condition>
        set <new property assignment>

        or

        using periodic commit 100
        call apoc.load.json(url) yield value
        match <condition>
        set <new property assignment>

    p299 특정 속성이 없는 모든 노드를 나열 ('hasRestaurant' 속성이 없는 모든 Tower 레이블 노드 리턴)

        match (n:Tower)
        where not exists(n.hasRestaurant)
        return n

        여기에 set 을 추가하여 교정할 수 있겠지. 이런 식으로.

        match (n:Tower)
        where not exists(n.hasRestaurant)
        set n.hasRestaurant = toBoolean("true")
        return n

        그보다 이런 데이터 불일치가 없도록 처음부터 제약 사항을 추가하는 게 더 낫겠다.

        create constraint on (t:Tower) assert exists(t.hasRestaurant)

    p299 모든 노드에서 속성 제거. 백업은 알아서 잘 하자.

        match n
        delete n.propertyName

    대변화

    p300 모델 파악

        # 3.1.2
        call db.schema()

        # 4 에서는 바뀐 듯
        call db.schema.visualization

    p301 리팩토링 도구

        TODO apoc.refactor 프로시저 패키지 잘 읽어보자

    p301 property를 label로 변환

        # hasRestaurant = true인 모든 Tower 노드에 대해,
        # HasRestaurant 레이블을 추가한 후 hasRestaurant 속성은 제거하려면

            match (t:Tower)
            where t.hasRestaurant
            set t:HasRestaurant
            remove t.hasRestaurant
            return t

        # Q: 엉? delete이 아니고 remove야?  delete은 node 삭제용이고, remove는 property 삭제용인가?

    p301 property를 Node로 변환

        # country: country_code 속성을 가진 모든 Tower에 대해,
        # Tower -[:IN_COUNTRY]->Country {code:t.country} 형태의 관계로 변환한다.

            match (t:Tower)
            merge (c:Country {code: t.country})
            create unique (t) - [:IN_COUNTRY] -> (c)
            remove t.country
            return t, c

        여기서 create unique는 관계를 unique 하게 만든다. 이 코드를 여러 번 실행해도 괜찮다.

    p302 Node를 Label로 변환

        Tower -- Country 관계가 있는 모든 Tower에 HasCountry 레이블 부여하기

            match (t:Tower) -- (c:Country)
            ste t:HasCountry

        비슷하지만 컨트로 코드값 (US, CA) 자체를 Label로 사용하려면

            match (t:Tower) -- (c:Country)
            call apoc.create.addLabels(id(t), [c.code]) yield node
            return node

    p303 여러 노드를 하나로 병합 (실수로 중복이 만들어져 데이터가 나뉘어졌을 때 유용할 듯)

        # 샘플 생성
        create (a:FIRST:MERGE {propF1: 'AF1', propF2: 'AF2'}),
               (b:SECOND:MERGE {propS1: 'BS1', propS2: 'BS2'}),
               (c:THIRD:MERGE {propT1: 'CT1', propT2: 'CT2'})

        # 샘플 확인
        match (n:MERGE)
        return n

        # 모든 노드를 FIRST 노드로 병합
        match (a:FIRST:MERGE), (b:SECOND:MERGE), (c:THIRD:MERGE)
        call apoc.refactor.mergeNodes([a,b,c]) yield node
        return node

    p304 관계 refactoring

        # 테스트 데이터 삭제
        match (n:MERGE) detach delete n

        # 테스트 데이터 생성
        create (a:FIRST:MERGE {name:'a', propF1: 'AF1', propF2: 'AF2'}),
               (b:SECOND:MERGE {name:'b', propS1: 'BS1', propS2: 'BS2', propF2: 'VALUE FROM SECOND'}),
               (c:THIRD:MERGE {name:'c', propT1: 'CT1', propT2: 'CT2', propF1: 'VALUE FROM THIRD'})
        create (a) - [:A2B] -> (b), (b) - [:B2B] -> (b), (a) - [:A2C] -> (c), (b) - [:B2C] -> (c)

        #
        call db.schema.visualization

        #
        match (n:MERGE) return n

        # A2B를 뒤집고 관계를 B2A로 다시 명명한다.  음 이거 apoc 프로시저 설치 필요하네.
        match (a:FIRST:MERGE) - [r:A2B] -> (b:SECOND:MERGE)
        call apoc.refactor.invert(r) yield output
        return output

        # 관계를 뒤집었다 치고. 이름도 A2B를 B2A로 바꾸어야겠지.
        match (a:FIRST:MERGE) - [r:A2B] - (b:SECOND:MERGE)
        call apoc.refactor.setType(r, 'B2A') yield output
        return output

        # 관계 r의 시작점을 c로 변경함
        match (a:FIRST:MERGE) - [r:B2A] - (b:SECOND:MERGE), (c:THIRD)
        call apoc.refactor.from(r, c)

        # 관계 r의 끝점을 a로 변경함
        match () - [r:B2B] - (), (a:FIRST)
        call apoc.refactor.to(r, a) yield output
        return output

chap 13 Neo4j 클러스터링

    skipped for now.

chap 14 사용 사례 - 추천

    # 제품 구매 기록 기반하여 제품 추천 #1

        # 사람 p1, p2가 같은 제품 prod1을 사고, p2가 prod2를 샀지만 p1은 prod2를 사지 않은 경우 p1에게 prod2를 추천
        match (p1:Person) - [:BOUGHT] -> (prod1:Product) <- [:BOUGHT] - (p2:Person) - [:BOUGHT] -> (prod2:Product)
        where not(p1-[:BOUGHT]->prod2)
        return p1.name as FirstPerson,
            p2.name as SecondPerson,
            prod1.name as CommonProduct,
            prod2.name as Recommended

        FIXME not 부분에 SyntaxError가 발생하는데?

    # 제품 구매 기록 기반하여 제품 추천 #2

        # 사람 p1, p2가 공통 제품 2가지를 샀고, p2가 prod2를 샀지만 p1은 prod2를 사지 않은 경우 p1에게 prod2를 추천
        match (p1:Person) - [:BOUGHT] -> (prod1:Product) <- [:BOUGHT] - (p2:Person) - [:BOUGHT] -> (prod2:Product)
        with p1, p2, count(prod1) as NumOfSharedProducts, collect(prod2) as SharedProducts, prod2
        where not(p1-[:BOUGHT]->prod2) and NumOfSharedProducts >= 2
        return p1.name as FirstPerson,
            p2.name as SecondPerson,
            extract(x in SharedProducts | x.name) as SharedProducts,
            prod2.name as Recommended

    # 브랜드 충성도에 기반을 둔 제품 추천 #3

        # 애플 제품을 2개 이상 가지고 있다면 또 다른 애플 제품을 추천해보자.
        match (p:Person) - [b:BOUGHT] -> (prod1:Product) - [:MADE_BY] -> (br:Brand) <- [:MADE_BY] - (prod2:Product)
        with p, br, prod2, count(prod1) as NumOfBrandProducts
        where not (p - [:BOUGHT] -> prod2) and NumOfBrandProducts > 1
        return p.name as Person, br.name as Brand, collect(prod2.name) as Recommended
        order by Person asc

        # FIXME 이것도 not 부분에 문법 에러.

    # 가족 관계에 기반을 둔 제품 추천

        # 나의 형제자매가 산 제품을 내가 가지고 있지 않다면 나에게 추천
        match (p:Person) - [b:BOUGHT] -> (prod:Product), p <- [r1] - (parent:Person) - [r2] ->  (sibling:Person)
        where type(r1) in ["MOTHER_OF", "FATHER_OF"] and type(r2) in ["MOTHER_OF", "FATHER_OF"] and not (sibling-[:BOUGHT]->prod)
        return p.name as Person, prod.naem as Recommended, collect(sibliong.name) as ForSibling

    # 보다 강력한 추천, 위 세 가지를 모두 합쳐 보자

        match (p1:Person) - [:BOUGHT] -> (prod1:Product) <- [:BOUGHT] - (p2:Person) - [:BOUGHT] -> (prod2:Product),
            p1 <- [r1] - (parent:Person) - (r2) -> p2,
            prod1 - [:MADE_BY] -> (br:Brand) <- [:MADE_BY] - (prod2)
        where type(r1) in ["MOTHER_OF", "FATHER_OF"] and type(r2) in ["MOTHER_OF", "FATHER_OF"] and not (p1 - [:BOUGHT] -> prod2)
        return p1.name as FirstPerson, p2.name as SecondPerson, br.name as Brand, prod2.name as Recommended

    more neo4j use cases

        부정 행위 탐지 fraud detection

        출입 통제 access control

        소셜 네트워킹

chap 15

    p345

        # BCP 분석: 어느 건물에 어느 애플리케이션이 사용되는가.
        match (app:Application) <- [:USES] - (proc:Process) - [:USED_BY] -> (bl:BusinessLine) - [:LOCATED_IN] -> (b:Building)
        return distinct app.name as Application, b.name as Building
        order by app.name asc

    p348

        # Loc_100에 RTO 0-2h인 BusinessProcess가 있는가?
        match (b:Building {name:"Loc_100"}), (rto:RTO {name: "0-2 hrs"}) <- [:BUSINESSPROCESS_HAS_RTO] - (bp:BusinessProcess)
        with b, bp
        match p = ShortestPath(b - [*..3] - bp)
        return p

    p354

        # 제품가격 트리에 대해 총 가격 계산
        match (n1:PRODUCT {id:1}) <- [r1] - (:COST_GROUP) <- [r2] - (:COST_TYPE) <- [r3] - (:COST_SUBTYPE) <- [r4] - (:COST) <- [r5] - (n6:COST_COMPONENT)
        return sum(r1.quantity * r2.quantity * r3.quantity * r4.quantity * r5.quantity * n6.price) as CalculatedPrice

    p355

        # 리프 노드의 가격을 계산하여 중간 노드에 저장하며 루트 노드로 나아간다. 최종적으로 루트 노드가 총 합계를 저장.
        match (n5:COST) <- [r5] - (n6:COST_COMPONENT)
        with n5, sum(r5.quantity * n6.price) as Sum
        set n5.price = Sum

        이것을 루트 노드까지 반복.

        # 가격 계산
        match (n1:PRODUCT {id:1} <- [r1] - (n2:COST_GROUP)
        return sum(r1.quantity * n2.price)

appendix

    p361 비밀번호 재설정

        data/dbms 아래의 auth 파일 삭제

    p365 Neo4j 브라우저 가이드

        https://github.com/neo4j-contrib/neo4j-guides

        http-server.py

            #! /usr/bin/env python
            import os
            try:
                from http.server import HTTPServer, SimpleHTTPRequestHandler
            except ImportError:
                from BaseHTTPServer import HTTPServer
                from SimpleHTTPServer import SimpleHTTPRequestHandler

            class CORSRequestHandler(SimpleHTTPRequestHandler):

                def end_headers (self):
                    self.send_header('Access-Control-Allow-Origin', '*')
                    self.send_header('Access-Control-Allow-Methods', 'GET')
                    self.send_header('Access-Control-Allow-Headers', '*')
                    self.send_header('Access-Control-Allow-Headers', 'Pragma,Cache-Control,If-Modified-Since,Content-Type,X-Requested-With,X-stream,X-Ajax-Browser-Auth')
                    SimpleHTTPRequestHandler.end_headers(self)

                def do_OPTIONS(self):
                    self.send_response(200)
                    self.end_headers()

            if __name__ == '__main__':
                HTTPServer(('0.0.0.0', 8001), CORSRequestHandler).serve_forever()

    p366 백업

        # 1
        data 폴더를 백업

        # 2
        neo4j-admin dump -to=<file> --database=<dbName>

        neo4j-admin load from=<file>

    p368 cypher-shell

        count.cy

            match (n)
            return count(n);

        cypher-shell -u uadmin -p uadmin --debug --format plain < count.cy

    p369 데이터 통합 도구

        www.talend.com

    p370 모델링 도구

        www.apcjones.com/arrows

        github.com/apcj/arrows

        omnigraffle

    p371 커뮤니티 프로젝트

        libcypher-parser

        structr

        neo4j-client.net

        ngraph.path

        popoto.js

        neo4j-graph-algorithms

    p372 온라인 문서

        neo4j.com/docs

        www.youtube.com/c/neo4j

        neo4j-apoc-procedures

    p372 커뮤니티

        stackoverflow.com/questions/tagged/neo4j

        neo4j.com/developer.com/slack/
